---
title : Ch.28.1 그래프의 깊이 우선 탐색

categories:
- jongman

tags:
- jongman
---

# 28.1 도입

- 트리의 순회와 같이 그래프의 모든 정점들을 특이한 순서에 따라 방문하는 알고리즘들을 그래프의
  탐색(search) 알고리즘이라고 합니다.
  - 트리의 순회는 사실 트리에 있는 정점들을 모두 확인한다는 것 외에 큰 의미가 없었지만, 그래프는
    트리보다 구조가 훨씬 복잡할 수 있기 때문에 탐색 과정에서 얻어지는 정보가 아주 중요합니다.

- 깊이 우선 탐색(depth-first search, DFS)은 그래프의 모든 정점을 발견하는 가장 단순하고 고전적인
  방법입니다.
- 현재 정점과 인접합 간선들을 하나씩 검사하다가, 아직 방문하지 않은 정점으로 향하는 간선이 있다면 그
  간선을 무조건 따라가는 거죠.

- 깊이 우선 탐색의 중요한 특성은 더 따라갈 간선이 없을 경우 이전으로 돌아간다는 점입니다.
  - 이것을 구현하기 위해서는 지금까지 거쳐온 정점들을 모두 저장해 둬야 하는데, 재귀 호출을 이용하면
    이와 같은 일을 간단하게 할 수 있습니다.


```cpp

// 그래프의 인접 리스트 표현
vector<vector<int> > adj;
// 각 정점을 방문했는지 여부를 나타낸다.
vector<bool> visited;
// 깊이 우선 탐색을 구현한다.
void dfs(int here){
    cout << "DFS visits " << here << endl;
    visited[here] = true;
    // 모든 인접 정점을 순회하면서
    for(int i = 0; i < adj[here].size(); ++i){
        int there = adj[here][i];
        // 아직 방문한 적 없다면 방문한다.
        if(!visited[there])
            dfs(there);
    }
    // 더이상 방문할 정점이 없으니, 재귀 호출을 종료하고 이전 정점으로 돌아간다.
}
// 모든 정점을 방문한다.
void dfsAll(){
    // visited를 모두 false로 초기화한다.
    visited = vector<bool>(adj.size(), false);
    // 모든 정점을 순회하면서, 아직 방문한 적 없으면 방문한다.
    for(int i = 0; i < adj.size(); ++i)
        if(!visited[i])
            dfs(i);
}
```
- 한 가지 유의할 점은 모든 정점에 대해 순서대로 dfs()를 호출하는 dfsAll()함수의 존재입니다.
- 그래프에서는 모든 정점들이 간선을 통해 연결되어 있다는 보장이 없기 때문에, dfs()만으로는 모든
  정점을 순서대로 발견한다는 목적에 부합하지 않습니다.
- 아래 그림처럼 서로 연결되지 않은 두 개의 부분으로 나뉘어진 경우의 그래프도 탐색해야하기
  때문입니다.

![img1](/img/2020-01-01-Jongman-ch28-1-1.png)

## 깊이 우선 탐색의 시간 복잡도

### 인접 리스트를 사용하는 경우

- dfs()는 한정점마다 한 번씩 호출되므로, 정확히 V번 호출됩니다.
- dfs() 한 번의 수행 시간은 모든 인접 간선을 검사하는 for문에 의해 지배되는데, 모든 정점에 대해
  dfs()를 수행하고 나면 모든 간선을 정확히 한 번(방향그래프) 혹은 두 번(무향 그래프) 확인함을 알 수
  있습니다.
- 따라서 복잡도는 O(V + E)입니다.

### 인접 행렬을 사용하는 경우

- dfs()는 한정점마다 한 번씩 호출되므로, 정확히 V번 호출됩니다.
- 하지만 인접 행렬을 사용할 때는 dfs() 내부에서 다른 모든 정점을 순회하며 두 정점 사이에 간선이
  있는가를 확인해야 하기 때문에 한번의 싱행에 O(V)의 시간이 듭니다.
- 따라서 전체 시간 복잡도는 O(V^2)이 됩니다.

## 예제: 연결된 부분집합의 개수 세기

> 컴포넌트(component)
- 위의 그림처러 무향 그래프가 간선으로 서로 연결되지 않은 몇 개의 조각으로 쪼개져 있을 경우, 각
  연결된 정점들의 부분집합을 컴포넌트(component) 혹은 요소라고 합니다.

## 예제: 위상 정렬

- 위상 정렬은 깊이 우선 탐색으로 풀 수 있는 가장 유명한 문제들 중 하나입니다.
- 위상 정렬은 의존성이 있는 작업들이 주어질 때, 이들을 어떤 순서로 수행해야 하는지 계산해 줍니다.
- 중요한 것은 작업들을 아무 순서로다 수행할 수 없다는 점입니다.
  - 작업 B를 하기 전에 반드시 작업 A를 해야 한다면, 작업 B가 작업 A에 의존한다고 말합시다.
- 각 작업을 정점으로 표현하고, 작업 간의 의존 관계를 간선으로 표현한 방향 그래프를 의존성
  그래프(dependency graph)라고 합니다.
- 의존성 그래프는 아래 그림과 같고, 알 수 있는 가장 큰 특성은 그래프에 사이클이 없다는 점입니다.
- 따라서 이 그래프는 사이클 없는 방향 그래프, 즉 DAG가 됩니다.

![img2](/img/2020-01-01-Jongman-ch28-1-2.png)

- 의존성 그래프의 정점들을 일렬로 늘어놓고, 왼쪽에서부터 하나씩 수행한다고 합시다.
- 이때 모든 의존성이 만족되려면, 모든 간선이 왼쪽에서 오른쪽으로 가야 합니다.
- 이렇게 DAG의 정점을 배열하는 문제를 위상 정렬(topological sort)라고 합니다.
- 아래 그림은 위의 그림의 정점들을 재배열하는 두 가지 방법을 보여줍니다.
  - (a) 의 모든 간선은 왼쪽에서 오른쪽으로 가고 있으므로 (a)는 적절한 위상 정렬 결과입니다.
  - (b) 는 오른쪽에서 왼쪽으로 가는 간선 (10,3)이 있으므로 적절한 위상 정렬 결과가 아닙니다.

![img3](/img/2020-01-01-Jongman-ch28-1-3.png)

- 위상 정렬을 구현하는 가장 직관적인 방법은 들어오는 간선이 하나도 없는 정점들을 하나씩 찾아서 정렬
  결과 뒤에 붙이고, 그래프에서 이 정점을 지우는 과정을 반복하는 것입니다.
- 깊이 우선 탐색을 이용하면 더 간단히 이 문제를 해결할 수 있습니다.
- 그 방법은 dfsAll()을 수행하며 dfs()가 종료할 때마다 현재 정점의 번호를 기록하는 것입니다.
- dfsAll()이 종료한 뒤 기록된 순서를 뒤집으면 위상 정렬 결과를 얻을 수 있습니다.
- 따라서 dfs()가 늦게 종료한 정점일수록 정렬 결과의 앞에 옵니다.
