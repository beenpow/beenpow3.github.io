---
title : swea::2105 [모의 SW 역량테스트] 디저트 카페

categories:
    - sweaB
    - swea
tag:
    - sweaB
    - swea
---
# swea::2105 [모의 SW 역량테스트] 디저트 카페
- [swea] : <https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5VwAr6APYDFAWu>
- Level : 

# 시사점
- 마름모 방향으로 순회하는 탐색문제입니다.
- 모든 경로를 순회해야 하므로, visit이 따로 필요 없습니다.
- 하지만, visit과 비슷한 개념인 dessert 의 종류로 구분합니다.
- 시작점은 마지막에 한번 더 방문되어야 하므로 잘 처리해주어야 합니다.

## 키
- 디저트 카페 투어

# 이해(5)
- 디저트 종류의 범위 [1,100]
- 각 정점당 정해진 디저트의 종류가 써진 맵을 부여받습니다.
- 특정 정점에서 시작하여, 마름모 방향으로 순회하며 종류가 겹치지 않는 최대 디저트의 수를
  출력합니다.

# 설계, 손 코딩(38)
- 손으로 중심이 되는 코드를 구현합니다.
- 먼저, 대각선 방향으므로 dx, dy를 설정해줍니다.
- 이후, 각 backtrack함수에서는 현재 가진 방향과 같은 방향으로 next지점을 방문하거나
  - 현재 가진 방향+1과 같은 방향으로 next지점을 방문할 수 있습니다.

## 시간 복잡도
- 정점(O(N^2)) * 한 정점담 최대로 만들 수 있는 마름모 꼴(2/N * 2/N * 2/N * 2/N)
  - 한 변의 최대 길이가 2/N이고, 경로문제이므로 네개의 변의 크기를 모두 곱해주었습니다.

## 공간 복잡도

# 손 코딩 후 문제 리뷰(2)
- 빼먹고 손 코딩 한 것이 있는지 확인합니다.

# 구현(15)

## 함수 List 

```cpp
// 범위를 초과하는지 체크합니다.
bool over(int x, int y);

// 현재 정점 [x,y]에서 d방향과 d+1방향으로 backtrack을 재귀시킵니다.
void backtrack(int x, int y, int d, int cnt, vector<bool>& slc);

// 모든 정점을 시작점으로 지정합니다.
// 방문할 수 있는 디저트 카페의 최대 수를 반환합니다.
int solve();
```

## 업데이트 되는 변수
- 대부분의 실수는 업데이트 되는 변수에서 발생합니다.

```cpp
int a[MAXN][MAXN]; // 전체 맵입니다.
vector<bool>& slc; // 함수의 매개변수 이지만, 잘 관리해줘야 합니다. 
```

## 실제 구현 

# 구현 후 코드리뷰 + 예제 돌려보기(x)
- 바로 예제를 넣어서 테스트 해보기 전에, 코드를 한 번 리뷰하고, 예제의 입력이 이런식으로 왔을때
  전체 코드가 어떤 식으로 순차적으로 진행되는지 답은 잘 도출될 것 같은지 확인합니다.

# 디버깅(x)

# 좋은 코드

# 최적화
