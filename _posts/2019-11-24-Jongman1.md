---
title : Ch 2 문제 해결 개관
categories:
- jongman

tags:
- jongman
---

Ch 2 문제 해결 개관
챕터의 제목에서 알 수 있듯이, 문제 풀이 접근법에 대해 다룹니다.
또한 해당 내용은 종만북의 내용을 부분 발췌하였으며, 문제가 될 시 게시글을 삭제하겠습니다.

 문제 해결 과정

#  문제를 읽고 이해하기
- 성급한 행동은 반드시 언젠가 더 큰 대가를 치루게 됩니다.
- 문제 설명을 공격적으로 읽으며 문제가 원하는 바를 완전히 이해하는 과정이 반드시 필요합니다.

#  재정의와 추상화
- 자신이 다루기 쉬운 개념을 이용해서, 문제를 자신의 언어로 풀어쓰는 과정입니다.
- 문제의 추상화란 현실 세계의 개념을 우리가 다루기 쉬운 수학적/전산학적 개념으로 옮겨 표현하는
  과정입니다.

#  계획세우기
- 이 과정에서는 문제를 어떤 방식으로 해결할지 결정하고, 사용할 알고리즘과 자료 구조를 선택합니다.

## 직관
- 문제 해결 전략에서 가장 먼저 갖오해야 할 것은 문제와 답의 구조에 대한 직관의 중요성입니다.
- 답안의 전체적인 얼개를 머릿속에 그릴 수 있으면 문제를 반쯤 해결한 것이나 마찬가지입니다.

## 체계적인 접근(을 위한 질문들)

### 비슷한 문제를 풀어본 적이 있던가?
- 형태가 비슷하거나 관련된 문제를 풀어 본 적이 있다면 이전에 적용했던 방법과 비슷한 접근 방법을
  사용할 거라고 예측할 수 있습니다.
- 물론 단순히 문제만 많이 푼다고 해서 그것이 다 경험이 되지는 않습니다. 풀어본 문제와 완전히 같은
  문제를 만날 확률은 적습니다.
- 기존에 접했던 문제가 온전히 경험이 되려면 그 원리를 완전히 이해하고 변형할 수 있어야 합니다.

### 단순한 방법에서 시작할 수 있을까?
- 시간과 공간 제약을 생각하지 않고 문제를 해결할 수 있는 가장 단순한 알고리즘을 만들어 보는
  것입니다.
- 필요시 좀더 효율적인 자료 구조를 사용하거나, 계산 과정에서 같은 정보를 두 번 중복으로 계산하지
  않는 등의 최적화를 적용해서 충분히 빨라질 때까지 알고리즘을 개선하는 식으로 문제를 풀 수 있습니다.

### 내가 문제를 푸는 과정을 수식화할 수 있을까?
- 공부를 하다 보면 처음에 생각한 것과 완전히 다른, 새로운 방향에서 접근해야 풀리는 문제들도 만나게
  됩니다.
- 이렇게 번뜩이는 영감이 핗요한 문제를 만났을 때 시도할 수 있는 방법 하나는 손으로 여러 간단한
  입력, 예를 들어 문제에 주어진 예제 입력을 직접 해결해 보는 것입니다.
- 자신이 문제를 해결한 과정을 공식화해서 답을 만드는 알고리즘을 만들 수 있는 경우가 흔히 있고,
  그렇지 못하더라도 이 과정에서 알고맂ㅁ이 어떤 점을 고려해야 하는지를 알게 되기 때문입니다.

### 문제를 단순화할 수 없을까?
- 문제를 쉽게 변형하는 방법은 여러가지 입니다.
    - 문제의 제약 조건 없애기
    - 계산해야 하는 변수의 수를 줄이기
    - 다차원의 문제를 1차원으로 줄여서 표현하기

### 그림으로 그려볼 수 있을까?
- 많은 사람들의 사고 체계는 숫자의 나열보다 기하학적 도형을 더 직관적으로 받아들이기 떄문입니다.

### 수식으로 표현할 수 있을까?
- 가능한 한 직관을 얻기 좋은 방향으로 사고를 전개하는 다른 접근 방식과는 반대로, 평문으로 쓰여 있는
  문제를 수식으로 표현하는 것도 도움이 되는 경우가 있습니다.
- 수식을 전개하거나 축약하는 등의 순수한 수학적 조작이 문제를 해결하는 데 큰 도움을 줄 수도 있기
  때문입니다.

### 문제를 분해할 수 있을까?
- 더 다루기 쉬운 형태로 문제를 변형하는 것입니다.
- 대표적인 예로 문제의 제약 조건을 분해하는 방법이 있습니다.
- 이 방법은 문제에 주어진 복잡한 조건을 더 단순한 형태를 갖는 조건의 집합으로 분해합니다.
- 한 개의 복잡한 조건보다 여러 개의 단순한 조건이 다루기 쉽기 때문에 이 변형은 종종 유용합니다.

### 뒤에서부터 생각해서 문제를 풀 수 있을까?
- 사다리 타기 문제와 같이, 정답점(도착점)을 지정하고 시작점방향으로 이동할 수 있습니다.

### 순서를 강제할 수 있을까?
- 순서를 뒤집는 방법의 연장선으로, 순서가 없는 문제에 순서를 강제해서 문제를 푸는 방법도 있습니다.

### 특정 형태의 답만을 고려할 수 있을까?
- 순서를 강제하는 기법의 연잔성으로 정규화 기법이 있습니다.
- 정규화란 우리가 고려해야 할 답들 중 형태가 다르지만 결과적으로는 똑같은 것들을 그룹으로 묶은 뒤,
  각 그룹의 대표들만을 고려하는 방법입니다.


#  계획 검증하기
- 구현을 시작하기 전에 계획을 검증하는 과정을 거쳐야 합니다.
- 이 과정에서는 우리가 설계한 알고리즘이 모든 경우에 요구 조건을 정확히 수행하는지를 증명하고,
  수행에 걸리는 시간과 사용하는 메모리가 문제의 제한 내에 들어가는지 확인해야 합니다.

#  계획 수행하기
- 구현 단계에서 유의할 점들과 좋은 프로그램을 작성하기 위한 가이드라인

## 좋은 코드를 짜기 위한 원칙

### 간결한 코드를 작성하기
- 코드가 짧으면 짧을수록 오타나 단순한 버그가 생길 우려가 줄어들고, 디버깅도 쉬워지기 때문입니다.
- C/C++ 매크로를 사용해 간결한 코드를 작성하는 것입니다. 이 기법은 반복문처럼 우리가 자주 타이핑하게
  되는 코드의 일부를 C++ 매크로로 표현합니다.
  '''cpp
  for(int i=0; i< array.size(); i++)
      for(int j=0; j<i; ++j)
          if(array[i] == array[j])
              return true;
  '''
    
  '''cpp
  #define FOR(i,n) for(int i=0; i<(n); ++i)

  FOR(i, array.size())
    FOR(j, i)
      if(array[i] == array[j])
        return true;
  '''

### 적극적으로 코드 재사용하기
- 간결한 코드를 작성하기 위한 가장 직접적인 방법은 코드를 모듈화하는 것입니다.
- 같은 코드가 반복된다면 이들을 함수나 클래스로 분리해 재사용하는 것입니다.
- 같은 코드가 3번 이상 등장한다면 항상 해당 코드를 함수로 분리해 재사용한다는 기본 원칙을 만들면
  좋습니다.

### 표준 라이브러리 공부하기
- 간결한 코드를 작성하기 위한 또 다른 중요한 원칙은 표준 라이브러리를 사용하는 것입니다.
- 표준 라이브러리는 셀 수 없을 정도로 많이 사용되고 검증되었기 때문에, 메모리 관리나 정당성 증명에
  신경 쓸 필요 없이 편하게 사용할 수 있습니다.

### 항상 같은 형태로 프로그램을 작성하기
- 이분법, 그래프의 너비 우선 탐색 등의 유명한 알고리즘부터, 2차원 평면의 점을 표현하는 자료구조, 두
  개의 구간이 서로 겹치는지를 확인하는 함수 등은 자주 사용됩니다.
- 같은 코드를 작성하는 더 좋은 방법에 대해 꾸준히 고민할 필요는 있지만, 자주 작성하는 알고리즘이나
  코드 등에 대해서는 한 번 검증된 코드를 작성하고 이것만을 꾸준히 사용할 필요가 있습니다.

### 일관적이고 명료한 명명법 사용하기
- 함수 이름만 무엇을 하는 함수인지 정확히 명명하는 것만으로도 코드를 읽기 쉬워집니다.

### 모든 자료를 정규화해서 저장하기
- 좋은 코드의 또 다른 원칙으로 같은 자료를 두 가지 형태로 저장하지 않는 것이 있습니다.

### 코드와 데이터를 분리하기
- 변하지 않는 데이터는 const 로 따로 저장해두고, 코드 부분은 별도로 작성하는 것이 좋습니다.
- 구분되어있어야 변경도 쉽고, 본연의 역할만 하기 쉽습니다.

## 자주 하는 실수

### 산술 오버플로
- 변수의 범위를 벗어나는 값을 사용하는 산술 오버플로입니다.

### 배열 범위 밖 원소에 접근
- int array[10], t; 를 선언하고 array[10] = 123;을 대입하는 경우 이는 t 변수에 123이 들어갈 가능성이
  있습니다.
- 이러한 에러는 디버깅도 쉽지 않습니다.
- 또한 0으로 시작하는 범위와 1로 시작하는 범위를 혼동하는 경우가 많습니다.

### 일관되지 않은 범위 표현 방식 사용하기
- 범위를 표현하는 방법에는 열긴구간 표현과 닫힌구간 표현이 있습니다.
- 모두 장단점이 있지만, 대부분 절충안인 반 열린 구간을 사용합니다. [lo, hi)
- 만약 함수 내에서 사용하는 표현방법과 함수 밖에서 사용하는 표현 방법이 서로 다르다면 혼란을 피할 수
  없습니다.
- 이 문제를 피하기 위해서는 프로그램 내에서 한 가지 방법으로만 범위를 표현할 필요가 있습니다.

### Off-by-one 오류
- Off-by-one 오류는 계산의 큰 줄기는 맞지만 하나가 모자라거나 하나가 많아서 틀리는 코드의 오류들을
  모두 가리킵니다.
- 이런 오류를 방지할 수 있는 좋은 방법은 최소 입력이 주어졌을 때 이 코드가 어떻게 동작할지를 되새겨
  보면서 프로그램을 짜는 것입니다.

### 컴파일러가 잡아주지 못하는 상수 오타
- 흔히 Human error라고 할 수 있는 부분입니다.
    - 0의 개수를 혼동하는 경우가 있습니다.

### 스택 오버플로
- 프로그램의 실행 중 콜 스택(call stack)이 오버플로해서 프로그램이 강제종료되는 것 또한 흔히 하는
  실수입니다.
- 스택 오버플로는 대게 재귀 호출의 깊이가 너무 깊어져서 오므로, 늘 유의하는 것이 좋습니다.
- C++의 경우 지역 변수로 선언한 배열이나 클래스 인스턴스가 기본적으로 스택 메모리를 사용하기 때문에
  특히나 스택 오버플로를 조심해야 합니다.
- 따라서 많은 사람들이 자동으로 힙에 메모리를 할당하는 STL컨테이너를 사용하거나 전역 변수를 사용하곤
  합니다.

### 다차원 배열 인덱스 순서 바꿔 쓰기
- 4,5차원 이상의 고차원 배열에서 인덱스의 순서를 헷갈려서 잘못쓰는 경우를 가리킵니다.

### 잘못된 비교 함수 작성
- 연산자 오버로딩을 진행할 때, if else의 확실한 예외처리를 하지 않는 경우를 포함합니다. 

### 최소, 최대 예외 잘못 다루기
- 예외란 우리가 예상한 입력의 규칙에 들어맞지 않는 모든 입력입니다.
- 가능한 입력 중 최소 값과 최대 값이 예외가 되는 문제들은 생각 외로 많으므로, 코드를 짤 때 가장 작은
  입력과 가장 큰 입력에 대해 제대로 동작할지를 생각해 보면 오류를 잡을 수 있는 경우가 꽤 있습니다.

### 연산자 우선순위 잘못 쓰기
- 한 예로 & 연산자와 == 연산자의 비교가 있습니다.
    - if ( b & 1 == 0 )   
    - 비트 단위 AND(&)연산자의 우선순위는 비교 연산자인 == 보다 낮기때문에 위의 if문은 아래와 같이
      해석됩니다.
    - if ( b & (1 == 0 ) )

### 변수 초기화 문제
- 이전 입력에서 사용한 전역 변수 값을 초기화하지 않고 그대로 사용하는 실수는 흔히 발생합니다.
- 완전하지는 않지만 이런 실수를 예방하기 위한 팁 하나는 예제 입력 파일을 두 번 반복해서 쓰는
  것입니다.

#  회고하기
- 회고란 자신이 문제를 해결한 과정을 돌이켜 보고 개선하는 과정을 말합니다.
- 효과적 회고 수행법은, 문제를 풀 때마다 코드와 함께 자신의 경험을 기록으로 남기는 것입니다.
- 한 번에 맞추지 못한 경우에는 오답 원인도 꼭 적는 것이 좋습니다.
- 회고를 위한 또 다른 좋은 방법은 같은 문제를 해결한 다른 사람의 코드를 보는 것입니다.
