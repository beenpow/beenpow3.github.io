---
title : BOJ::2819 상근이의 로봇

categories:
    - sweaB
    - BOJ
    - 백준
tag:
    - sweaB
    - BOJ
    - 백준
---
# BOJ::2819 상근이의 로봇
- [Link : BOJ::2819](https://www.acmicpc.net/problem/2819)
- Level : Gold 1

# 시사점
- 누가봐도 그냥 구현하면 시간초과를 불러일으키는 문제였습니다.
- 시간초과를 막기 위해 펜을 굴리며 생각하는데, 설계하는데 시간을 들였습니다.
- 결국, 맨해튼 거리라는 것은 abs(xi-x) + abs(yi-y)를 구하는 것입니다.
- 이때, x 부분과 y 부분은 전혀 연관이 없으므로 따로 구해도 무방합니다.
- 이제, abs라는 문제만 해결하면 시간을 줄일 수 있습니다.

## 키
- #로봇

# 이해(10)
- 조사점과 로봇의 이동방향이 주어집니다.
- 로봇은 (0,0)부터 시작해서 이동방향에 맞게 이동합니다.
  - 매 이동마다 조사점 리스트와의 맨해튼 거리의 합을 도출합니다.

# 설계, 손 코딩(27)
- 손으로 중심이 되는 코드를 구현합니다.
- 조사점은 10^5개, 로봇의 이동은 3 * 10^5 개, input은 abs(10^6) 범위 입니다.
- 즉, 로봇이 이동하고 조사점 List마다 순회하며 맨해튼 거리를 구하면 O(10^10)이 되어 시간초과를
  받을게 뻔합니다.
- 이때, 맨해튼 거리를 분해해보면 답을 도출할 수 있습니다.
- 즉, 로봇이 이동후 각 조사점과의 맨해튼 거리인 abs(xi-x) + abs(yi-y)를 구합니다.
  - 하지만, 자세히 보면 x 부분과 y부분은 양수끼리 더하는 것일뿐 연관성이 없습니다.
  - 따라서, xi[MAXN] 부분과 yi[MAXN]부분으로 나눌 수 있습니다.
  - 또한 abs xi-x 를 풀어쓰면,
    - xi >= x 일땐, xi -x 가 되고,
    - xi < x 일땐, x - xi가 됩니다.
    - 즉 xi의 List 중 x에 대한 lower_bound를 구하고, 해당 position의 좌측은 x보다 작은 값들의
      모임이고, 우측은 x 이상인 값들의 모임입니다.
      - 물론, 정렬한 이후를 의미합니다.
    - 물론 position만 구했다고 해도 값들의 모임의 합을 구해줘야 합니다.
    - 이를 단축시키기 위해 psum을 사용했습니다.

## 시간 복잡도
- precalc() : O(N)
- simulate() : O(M) * O(logN)

## 공간 복잡도

# 손 코딩 후 문제 리뷰(x)
- 빼먹고 손 코딩 한 것이 있는지 확인합니다.

# 구현(40)

## 함수 List 

```cpp
// 조사점인 xi, yi 각각을 정렬한 후, psumx와 psumy를 구합니다.
void precalc();

// value 이상인 첫 position을 int형으로 반환합니다.
int my_lower_bound(int A[], int value);

// value(x혹은 y)와 남은 정점 들간의 맨해튼 거리의 합을 반환합니다.
ll summing(int value, int*ai, ll *psum);

// 주어진 방향으로 이동된 x, y가 입력됩니다.
// (x, y)와 조사점 사이의 합을 출력합니다.
void simulate(int x, int y);
```

## 업데이트 되는 변수
- 대부분의 디버깅 문제는 업데이트 되는 변수에서 발생합니다.

```cpp
// 업데이트 되는 변수 ------------------------------------
int xi[MAXN], yi[MAXN];
ll psumx[MAXN], psumy[MAXN];
// 업데이트 되는 변수 ------------------------------------
```

## 실제 구현 

```cpp
#include<bits/stdc++.h>
typedef long long ll;
const int MAXN = 1 * 100000 + 2, MAXM = 3 * 100000;
const char seq[] = {'S', 'J', 'I', 'Z'};
const int dx[] = {0, 0, 1, -1}, dy[]={1, -1, 0, 0};
using namespace std;

int n, m;
int sx = 0, sy = 0;

// 업데이트 되는 변수 ------------------------------------
int xi[MAXN], yi[MAXN];
ll psumx[MAXN], psumy[MAXN];
// 업데이트 되는 변수 ------------------------------------

// 조사점인 xi, yi 각각을 정렬한 후, psumx와 psumy를 구합니다.
void precalc(){
    sort(xi+1, xi + n+1);
    sort(yi+1, yi + n+1);
    psumx[1] = xi[1];
    psumy[1] = yi[1];
    for(int i = 2; i <= n; i++){
        psumx[i] = psumx[i-1] + xi[i];
        psumy[i] = psumy[i-1] + yi[i];
    }
}
// value 이상인 첫 position을 int형으로 반환합니다.
int my_lower_bound(int A[], int value){
    int start = 1, end = n, mid = 1, ret = n+1;
    while(start <= end){
        mid = (end + start) / 2;
        if(A[mid] == value){
            end = mid-1;
            ret = min(ret, mid);
        }
        else if(A[mid] > value){
            end = mid-1;
            ret = min(ret, mid);
        }else{
            start = mid+1;
        }
    }
    return ret;
}

ll summing(int value, int*ai, ll *psum){
    ll ret = 0;
    int pos = my_lower_bound(ai, value);
    pos -= 1;
    // ai에 포함된 모든 수는 value 보다 작음을 의미합니다.
    if(pos == n){
        ret = (value * pos - (psum[pos]));
    }
    else{
        // 이제 pos는 value보다 작은 값 중 가장 큰 값을 가리킵니다.
        // ai에 포함된 모든 수가 value 초과임을 의미합니다.
        if(pos == 0){
            ret = ((psum[n] - psum[pos]) - value * (n-pos));
        }else{
            ret = (value * pos - (psum[pos])) + ((psum[n] - psum[pos]) - value * (n-pos));
        }
    }

    return ret;
}


// 주어진 방향으로 이동된 x, y가 입력됩니다.
// (x, y)와 조사점 사이의 합을 출력합니다.
void simulate(int x, int y){
    ll sum =  summing(x, xi, psumx) + summing(y, yi, psumy);
    cout << sum << endl;
}

int main(){
    freopen("input.txt", "r", stdin);
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m;

    for(int i = 1; i <= n; i++)
        cin >> xi[i] >> yi[i];

    precalc();
    string str = "";
    cin >> str;

    for(int i = 0; i < str.size(); i++){
        for(int j = 0; j < 4; j++){
            if(str[i] == seq[j]){
                simulate(sx += dx[j], sy += dy[j]);
                break;
            }
        }
    }
    return 0;
}
```

# 구현 후 코드리뷰 + 예제 돌려보기(x)
- 바로 예제를 넣어서 테스트 해보기 전에, 코드를 한 번 리뷰하고, 예제의 입력이 이런식으로 왔을때
  전체 코드가 어떤 식으로 순차적으로 진행되는지 답은 잘 도출될 것 같은지 확인합니다.

# 디버깅(5)
- 시간초과가 나지 않도록 구현했음에도 시간초과가 떴었습니다.
- endl이 범인이었고, 실수를 수정하자 바로 맞았습니다.

# 좋은 코드

# 최적화
