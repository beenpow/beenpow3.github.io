---
title : Ch.28.7 이론적 배경과 응용

categories:
- jongman

tags:
- jongman
---

# 이론적 배경과 응용

- 깊이 우선 탐색의 +a 버전이라고 생각합니다.

## 깊이 우선 탐색과 간선의 분류

- 그래프의 간선들을 분류하면 그래프의 구조에 대해 많은 것을 배울 수 있습니다.

![img1](/img/2020-01-01-Jongman-ch28-7-1.png)

- 그림 (a)의 그래프를 0번 정점에서부터 깊이 우선 탐색했을 때 탐색이 따라가는 간선들을 굵은 실선으로
  표시하면 그림 (b)를 얻을 수 있습니다.
- 굵은 실선이 0번 정점을 루트로 하는 트리 형태를 띠는 것을 볼 수 있습니다.
> 이런 트리를 주어진 그래프의 깊이 우선 탐색 스패닝 혹은 DFS 스패닝 트리(DFS Spanning Tree)라고
> 부릅니다.


- 그래프의 DFS 스패닝 트리를 생성하고 나면 그래프의 모든 간선을 다음과 같이 네 가지 중 하나로 분류할
  수 있습니다.
  - 트리 간선(tree edge)
    - 스패닝 트리에 포함된 간선을 의미합니다.
    - 그림 (b)에서 굵은 선으로 표시된 간선들이 모두 트리 간선입니다.
  - 순방향 간선(forward edge)
    - 스패닝 트리의 선조에서 자손으로 연결되지만 트리 간선이 아닌 간선을 말합니다.
    - 그림 (b)의 (0, 6) 간선이 순방향 간선의 예입니다.
  - 역방향 간선(back edge)
    - 스패닝 트리의 자손에서 선조로 연결되는 간선을 말합니다.
    - 그림 (b)의 (2, 0) 같은 간선이 역방향 간선의 예입니다.
  - 교차 간선(cross edge)
    - 위의 세 가지 분류를 제외한 나머지 간선들을 의미합니다.
    - 교차 간선은 트리에서 선조와 자손 관계가 아닌 정점들 간에 연결된 간선들을 의미합니다.
    - 그림 (b)에서 (6, 3) 같은 간선이 교차 간선의 예입니다.


## 간선 분류의 예
- 그래프를 그림으로 그려놓고, 깊이 우선 방문 탐색을 진행하며 
  - 최초 방문한 지점은 "트리 간선"
  - 스패닝 트리의 한 노드에서 선조로 가는 간선은 "역행 간선"
  - 스패닝 트리의 한 노드에서 후손으로 가는 간선은 "순방향 간선"(트리 간선 제외)
  - 서로 조상도 후손도 아닌 간선을 "교차 간선"
- 으로 구별해갈 수 있습니다.


## 무향 그래프 간선의 분류

- 무향 그래프의 모든 간선은 양방향으로 통행 가능하므로, 무향 그래프에는 교차 간선이 있을 수
  없습니다.
- 또한 무향 그래프의 경우 순방향 간선과 역방향 간선의 구분이 없다는 점도 유념해야 합니다.

## 예제: 위상 정렬의 정당성 증명

- 간선의 분류는 그 자체가 유용하다기보다는 그래프 알고리즘을 이해하고 증명하기 위한 도구로 유용하게
  쓰입니다.
- 이를 이용해 위상 정렬의 정당성을 증명해 보겠습니다.
  - 참고로 위상 정렬이 시사하는 아래 fact에 대해 정당성을 증명합니다.
  - dfsAll()을 수행하며 dfs()가 종료할 때마다 현재 정점의 번호를 기록하고,
  - dfsAll()이 종료한 뒤 기록된 순서를 뒤집으면 위상 정렬 결과를 얻을 수 있습니다.
  - 따라서 dfs()가 늦게 종료한 정점일수록 정렬 결과의 앞에 옵니다.
- 우리의 위상 정렬 알고리즘은 dfs()의 종료 역순으로 정점을 배열하므로, dfs(u)가 dfs(v)보다 일찍
  종료할 경우 u에서 v로 가는 간선이 존재할 수 없다는 것만 증명하면 그 정당성을 보일 수 있습니다.
  - 이를 위해 (u, v) 간선이 4가지 종류의 간선인 모든 경우에 대해 증명합니다.
- (u, v)가 트리 간선이라면,
  - dfs(u)에서 dfs(v)를 호출 했다는 말인데, 그러면 dfs(u)가 먼저 종료할 수 없습니다.
- (u, v)가 역방향 간선이라면,
  - v가 u의 선조이므로 v에서 u로 가는 경로가 있다는 뜻인데, 여기에 (u,v)를 붙이면 사이클이 되므로
    그래프가 DAG라는 가정에 모순됩니다.
- (u, v)가 순방향 간선이라면,
  - u가 v의 선조라는 뜻인데, 이때 dfs(u)가 먼저 종료하는 것은 불가능합니다.
- (u, v)가 교차 간선이라면,
  - dfs(v)가 종료하고 나서 u를 방문했다는 뜻인데, 이것은 dfs(u)가 먼저 종료했다는 것과 모순입니다.

- 따라서 이와 같은 간선 (u,v)는 존재할 수 없고, 위상 정렬의 정당성은 증명됩니다.
 
## 예제: 사이클 존재 여부 확인하기

## 간선을 구분하는 방법

## 예제: 절단점 찾기 알고리즘

## 예제: 다리 찾기

## 예제: 강경합 컴포넌트 분리

## 강경합 컴포넌트 분리를 위한 타잔의 알고리즘

## 강경합 컴포넌트 분리 알고리즘의 구현

## SCC 위상 정렬

