---
title : BOJ::16933 벽 부수고 이동하기3

categories:
    - sweaB
    - BOJ
tag:
    - sweaB
    - BOJ
---
# BOJ::16933 벽 부수고 이동하기 3
[BOJ] : <https://www.acmicpc.net/problem/16933>
- Level : Gold 2

# 시사점
- 처음 보는 유형의 문제입니다.
- 모든 탐색문제가 그렇듯이 상태를 정의하는 것이 중요합니다.
- 현재 위치에 머무르는 nx, ny일때는 다음 위치가 1인지 0인지 확인하지 않아야 합니다.
  - 여기서의 다음 위치는 현재위치를 의미합니다.

# 이해(4)


# 설계(2)
- bool status[MAX_N][MAX_M][MAX_K][DAY/NIGHT] 으로 상태를 정의합니다.

## 시간 복잡도

## 공간 복잡도

# 구현(24)

```cpp
// 큰 실수 : 현재 위치에 머무를땐, a[][]가 1인지 아닌지 확인할 필요가 없을듯
#include<bits/stdc++.h>
#define DAY 0
#define NIT 1
const int MAX_K = 10 + 1 ; // 실수 10으로 설정함
const int MAX_N = 1000;
const int DAYNIGHT = 2;
const int INF = 987654321;
const int dx[]={-1, 0, 1, 0, 0}, dy[]={0, 1, 0, -1, 0};
struct cell{int x;int y;int usedK;bool night;int time;};
using namespace std;

queue<cell> q;
int n, m, mxK;
int a[MAX_N][MAX_N];
bool status[MAX_N][MAX_N][MAX_K][DAYNIGHT];
bool over(int x, int y){return (x<0 ||y<0 || x>=n || y>=m);}

void bfs(int sx, int sy, int ex, int ey){
    int ret = INF;
    q.push({sx, sy, 0, DAY, 1});
    status[sx][sy][0][DAY] = true;
    while(!q.empty()){
        int x = q.front().x, y = q.front().y, usedK = q.front().usedK, time = q.front().time;
        bool night = q.front().night; q.pop();
        if(x == ex && y == ey){
            ret = time;
            break;
        }

        bool nn = !night;int ntime = time+1;
        for(int i = 0; i < 5; i++){
            int nx = x+dx[i], ny = y+dy[i];
            if(over(nx, ny)) continue;
            if(i != 4){
                if(a[nx][ny] == 1){
                    if(usedK < mxK && night == DAY && !status[nx][ny][usedK+1][nn]){
                        status[nx][ny][usedK+1][nn] = true;
                        q.push({nx, ny, usedK+1, nn, ntime});
                    }
                }else{
                    if(status[nx][ny][usedK][nn]) continue;
                    status[nx][ny][usedK][nn] = true;
                    q.push({nx, ny, usedK, nn, ntime});
                }
            }else{
                if(status[nx][ny][usedK][nn]) continue;
                status[nx][ny][usedK][nn] = true;
                q.push({nx, ny, usedK, nn, ntime});
            }
        }
    }
    if(ret == INF)printf("-1\n");
    else printf("%d\n",ret);
}
int main(){
    freopen("input.txt", "r", stdin);
    scanf("%d %d %d", &n, &m, &mxK);
    for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++){
            scanf("%1d",&a[i][j]);
        }
    bfs(0, 0, n-1, m-1);
    return 0;
}
```

# 디버깅(30)
- 두 가지 실수를 저질렀습니다.
- 첫번째는 MAX_K를 10으로 설정한 것입니다.
  - 수정하여 10 +1 로 고쳤습니다.

- 두번째는, 시사점 챕터에서 언급하였지만,
  - nx, ny를 구하고 다음 위치를 나누는 기준이 문제되었습니다.
  - 최초 시도할땐, 단순히 다음위치가 1인지 0인지 만으로만 구분하였습니다
  - 하지만 이럴 경우, 현재 위치가 1이고 다음위치는 머무르는 선택을 할때, 예외처리가 되지 않았습니다.
  - 즉, 머무를지 말지를 먼저 결정한 후,
    - 머무르지 않는 경우에만 벽인지 벽이 아닌지를 확인하도록 수정하였습니다.

# 좋은 코드

# 최적화
