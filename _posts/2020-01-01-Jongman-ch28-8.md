---
title : Ch.28.8 문제 ID GALLERY

categories:
- jongman

tags:
- jongman
---

# 28.8 문제: 감시 카메라 설치 ( 문제ID : GALLERY, 난이도: 중)
[algo]: <https://algospot.com/judge/problem/read/GALLERY>

- 문제 분류
  - 지배 집합의 개념
  - 루트 없는 트리의 성립 조건
  - 루트 없는 트리로 문제를 푸는 방법
  - 재귀 함수의 종료 조건에 어떤 trigger를 방법
  - 자식의 return 종류를 children[]으로 받아서 사용하는 방법

## 지배 집합 찾기

> 자기 자신과 모든 인접한 정점들을 지배한다고 할 때, 그래프의 모든 정점을 지배하는 정점의 부분집합을
> 그래프의 지배 집합(dominating set)이라고 부릅니다.
- 가장 좋은 알고리즘도 정점 개수의 지수 함수에 비례하는 시간이 걸리므로, 이 문제의 정점이 최대
  1000개 임을 고려할때 해당 방법은 사용할 수 없습니다.


## 루트 없는 트리

- 이 문제에 숨어있는 힌트가 있습니다.
  - "미술관에서 한 번 지나간 갤러리를 다시 지나기 위해서는 전에 지난 복도를 반드시 지나야 합니다."
  - 이 속성의 중요한 의미는 미술관을 표현하는 그래프에는 사이클이 존재하지 않는다는 것입니다.

- 사이클이 존재하지 않는 그래프는 노드 간의 상하 관계가 없을 뿐이지 트리와 같은 형태를 가지고
  있습니다.

> 이와 같은 그래프들을 루트 없는 트리(unrooted tree)라고 부릅니다.
- 그래프에 대해 풀기 어려운 여러 문제들이 트리에 대해서는 쉽게 풀리는 경우가 많기 때문에,
- 주어진 그래프가 사실 루트 없는 트리인지 파악하는 것이 문제를 푸는 데 중요한 역할을 하는 경우가
  많습니다.
- 어떤 연결된 그래프가 루트 없는 트리인지 확인하려면, 다음 속성 중 하나라도 성립하는지를 확인하면
  됩니다.
  - 정확히 V-1개의 간선이 있습니다.
  - 사이클이 존재하지 않습니다.
  - 두 정점 사이를 연결하는 단순 경로가 정확히 하나 있습니다.
- 이 조건들은 모두 동치로, 한 조건이라도 성립할 경우 다른 조건들이 모두 성립하게 됩니다.

## 루트 없는 트리에서 문제 풀기

- 루트 없는 트리를 다루는 가장 간단한 방법은 임의의 시작점으로부터 깊이 우선 탐색을 수행하는
  것입니다.
- 결과적으로 얻은 깊이 탐색 스패닝 트리는 원래 그래프의 구조를 그대로 갖고 있으면서, 부모 자식
  관계를 갖는 일반적인 트리가 됩니다.

> 그래프가 트리 형태를 갖고 있다는 사실을 눈치채고 나면 문제에 접근하기가 수월해집니다.
```cpp
예를 들어 최대 10만개의 정점을 갖는 연결된 그래프에서 서로 가장 멀리 떨어진 두 점을 찾아내는 문제가
있다고 합시다.
정점의 개수가 너무 크기 때문에 각 정점에서 시작해서 너비 우선 탐색을 할 수는 없을 겁니다.
그런데 문제 설명 어딘가에 두 정점을 연결하는 단순 경로는 최대 하나만 존재한다는 언급이 살짝
숨어있었다고 합시다.
그러면 이 문제의 그래프는 루트 없는 트리라는 것을 알 수 있습니다.
이것을 트리 형태로 만들면 21장의 요새 문제에서 봤던 것처럼 트리의 지름을 구하는 문제가 되고, 한 번의
탐색으로 문제를 해결할 수 있게 됩니다.
```
[21장 요새문제]:<https://beenpow.github.io/jongman/2019/12/26/Jongman-ch21-5/>

## 트리의 지배 집합 찾기

- 트리의 최소 지배 집합을 찾는 가장 간단한 방법은 트리의 맨 아래에서부터 시작해서 위로 올라오는
  것입니다.
> 트리의 특성(루트없는 트리 + 지배 집합 문제인 경우)
- 트리의 루트를 선택해야 할지 말아야 할지는 미리 알기 쉽지 않은 반면,
- 트리의 잎 노드를 선택할지 말지를 정하기란 아주 쉽습니다.
- 잎 노드는 자기 자신과 부모밖에 지배하지 못하는 반면,
- 부모 노드는 그 외의 노드들도 지배할 수 있습니다.
- 따라서 잎 노드 대신 그 부모 노드를 선택해서 손해볼 일은 절대로 없고,
- 잎 노드는 절대로 선택할 필요가 없습니다.

```cpp
1. 잎 노드는 선택하지 않습니다.
2. 이 외의 노드에 대해, 트리의 맨 밑에서부터 올라오면서 다음과 같이 선택 여부를 결정합니다.
  (a) 자기 자손 중 아직 지배당하지 않은 노드가 하나라도 있다면 현재 노드를 선택합니다.
  (b) 이 외의 경우 현재 노드를 선택하지 않습니다.
```

```cpp
int V;
vector<int> adj[MAX_V];
vector<bool> visited;
const int UNWATCHED = 0;
const int WATCHED = 1;
const int INSTALLED = 2;
// 지금까지 설치한 카메라의 총 수
int installed;
// here로부터 깊이 우선 탐색을 하고, here의 정보를 반환한다.
int dfs(int here){
    visited[here] = true;
    int children[3] = {0, 0, 0};
    for(int i = 0; i < adj[here].size(); ++i){
        int there = adj[here][i];
        if(!visited[there]){
            ++children[dfs(there)];
        }
    }
    // 자손 노드 중 감시되지 앟는 노드가 있을 경우 카메라를 설치한다.
    if(children[UNWATCHED]){
        installed++;
        return INSTALLED;
    }
    // 자손 노드 중 카메라가 설치된 노드가 있을 경우 설치할 필요가 없다.
    if(children[INSTALLED]){
        return WATCHED;
    }
    return UNWATCHED;
}
// 그래프를 감시하는 데 필요한 카메라의 최소 수를 반환한다.
int installedCamera(){
    installed = 0;
    visited = vector<bool>(V, false);
    for(int u = 0; u < V; ++u)
        if(!visited[u] && dfs(u) == UNWATCHED)
            installed++;
    return installed;
}
```
