---
title : Ch.17.2 문제 ID  CHRISTMAS

categories:
- jongman

tags:
- jongman
---

# 17.2 문제: 크리스마스 인형( 문제ID : CHRISTMAS, 난이도: 중)
[algo]: <https://algospot.com/judge/problem/read/CHRISTMAS>

- 저자의 풀이는 심도있다.
- modular 연산의 정의를 이용하여 풀이를 하며, 주의를 기울여 따라가야 이해할 수 있는 것 같다.
- 직접 풀어보려 시도했을때는, 겹치지 않고 구입할 수 있는 최대 횟수를 구할때 사용하는 메모이제이션
  혹은 조각 함수의 정의를 주어진 메모리 내에서 정의하기가 어려워서 실패했다.

# 풀이

> "H에서 T까지 구입했을 때 남기지 않고 어린이들에게 나눠줄 수 있는가?"라는 문제를 부분합으로 대답할
> 수 있습니다.


- 어린이들에게 인형을 모두 나눠주려면 인형의 총 수가 K의 배수여야 합니다.

```cpp
(psum[T] - psum[H-1]) mod K = 0
```

- 위의 식을 풀어쓰면 아래와 같습니다.

```cpp
psum[T] mod K = psum[H-1] mod K
```

- psum[]에서 중요한 것은 K로 나눈 나머지일 뿐이라는 사실을 알 수 있습니다.
- 따라서 이 문제에서는 psum[]을 다음과 같이 정의하기로 합시다.

![img1](/img/2019-12-21-Jongman-ch17-2-1.png)


## 구입할 수 있는 방법의 수 계산 ( 이해가 잘 가지 않는 부분 )

> H번째부터 T번째 상자까지를 주문했을 때 K명의 어린이에게 모두 나눠줄 수 있다는 말은 
> 항상 psum[H-1] = psum[T]라는 뜻입니다.
- 따라서 psum[]의 각 원소를 모두 같은 것끼리 모읍시다.
- 이들 중 두개를 선택하면 한 번의 주문이 됩니다.
- 따라서 숫자 i가 psum에 출현하는 횟수를 f_i 라고 할 때 우리가 원하는 값은 다음과 같습니다.

![img2](/img/2019-12-21-Jongman-ch17-2-2.png)

## 겹치지 않고 구입할 수 있는 최대 횟수 계산하기

- 동적계획법을 이용해 서로 겹치지 않는 부분 구간을 가장 많이 골라내는 함수를 다음과 같이 정의할 수
  있습니다.

```cpp
maxBuys(i) = 0번 상자부터 i번 상자까지의 범위 내에서 서로 겹치지 않고 구매할 수 있는 부분 구간의
             최대 수
```

> 이때 i번 상자를 가지고 할 수 있는 일은 두 가지밖에 없습니다.
- 1. i 번 상자를 사지 않는 경우 : 이 상자를 제외하고 나머지 상자들에 대해 재귀호출로 문제를
     해결합니다. 따라서 이경우의 답은 maxBuys(i-1)이 됩니다.
- 2. i번 상자를 사는 경우: 항상 상자는 범위로만 살 수 있기 때문에, j(j<=i)번 상자에서 i번 상자까지를
     한 번에 사야 합니다. 그러기 위해서는 psum[j-1] = psum[i]여야 합니다.
     - 만약 j로 선택할 수 있는 상자가 여러 개 있을 수 있다면 그 중 어느 것을 선택해야 할까요?
     - 가장 뒤에 있는 상자를 구입해야만 이득임을 어렵지 않게 알 수 있습니다.
     - 우리의 목적은 가능한 한 많은 상자를 사는 것이 아니라 구간의 수를 최대화하는 것이기
       때문입니다.
     - 이와 같이 j를 선택한 경우의 답은 maxBuys(j-1) + 1 이 됩니다.


## 구현 

- psum[]의 첫 번째 원소 이전에 0을 하나 추가로 집어 넣어서 psum[-1] = 0이라는 우리의 가정을 현실로
  옮깁니다.
  - 그러면 psum[i] = psum[j=1]인지를 확인할 때 j = 0인 예외에 대해 신경쓰지 않아도 되기 때문에
    신경쓰지 않아도 되기 때문에 훨씬 구현이 간단해집니다.

- wayToBuy()는 첫 번째 문제의 답을 구하기 위해 psum[]의 각 값의 출현 빈도수를 계산한 후, 각 빈도 f에
  대해 (f C 2)의 합을 계산합니다.
- psum[]의 맨 앞에 0을 넣어두었기 때문에 맨 앞 상자에서부터 구입하는 경우를 예외로 처리하지 않아도
  된다는 점, 그리고 (f C 2)를 구할 때 오버플로우를 피하기 위해 64비트 정수를 사용하는 부분을 눈여겨
  봅시다.

- 아래 두 함수의 시간 복잡도는 모두 O(N+K)입니다.

```cpp
// D[]의 부분 합 배열 psum[]과 k가 주어질 때, 몇 가지 방법으로 살 수 있는지 반환한다.
// psum[]의 첫 번째 원소 전에 0을 삽입했다고 가정한다.
int wayToBuy(const vector<int>& psum, int k){
    const int MOD = 20091101;
    int ret = 0;
    // psum[]의 갓 값은 몇 번이나 본 적 있는지 기록한다.
    vector<long long > count(k, 0);
    for(int i = 0; i < psum.size(); i++)
        count[psum[i]]++;
    // 두 번 이상 본 적 있다면 이 값 중 두 개를 선택하는 방법의 수를 더한다.
    for(int i = 0; i < k; i++)
        if(count[i] >= 2)
            ret = (ret + ((count[i] * (count[i] -1)) / 2)) % MOD;
    return ret;
}

// D[]의 부분 합 배열 psum[]과 k가 주어질 때, 겹치지 않게 몇 번이나 살 수 있는지 반환한다.
// psum[]의 첫 번째 원소 전에 0을 삽입했다고 가정한다.
int maxBuys(const vector<int>& psum, int k){
    // ret[i] = 첫 번째 상자부터 i번째 상자까지 고려했을 때 살 수 있는 최대 횟수
    vector<int> ret(psum.size(), 0);
    // prev[s] = psum[]이 s였던 마지막 위치
    vector<int> prev(k, -1);
    for(int i = 0; i < psum.size(); ++i){
        // i번째 상자를 아예 고려하지 않는 경우
        if(i > 0)
            ret[i] = ret[i-1];
        else
            ret[i] = 0;
        // psum[i]를 전에도 본 적 있으면, prev[psum[i]]+1부터 여기까지 쭉 사본다.
        int loc = prev[psum[i]];
        if(loc != -1) ret[i] = max(ret[i], ret[loc] + 1);
        // prev[]에 현재 위치를 기록한다.
        prev[psum[i]] = i;
    }
    return ret.back();
}
```

