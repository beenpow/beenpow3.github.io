---
title : Ch.19.1 큐와 스택, 데크

categories:
- jongman

tags:
- jongman
---

# 19.1 도입

## 큐와 스택, 데크

- 큐와 스택, 데크는 일렬로 늘어선 같은 형태의 자료들을 저장합니다.
- 이때 세 자료 구조들을 구분하는 것은 어느 쪽 끝에서 자룔를 넣고 뺄 수 있는가입니다.

> 큐(queue)에서는 한쪽 끝에서 자료를 넣고 반대 쪽 끝에서 자료를 꺼낼 수 있습니다.
- 이 속성을 선입선출(FIFO, First In First Out)이라고도 부릅니다.

> 스택(stack)에서는 한쪽 끝에서만 자료를 넣고 뺄 수 있습니다.
- 이 속성을 후입선출(LIFO, Last In First Out)이라고도 부릅니다.

> 데크(dequeue)는 양쪽 끝에서 자료들을 넣고 뺄 수 있는 자료 구조를 말합니다.


# 19.2 큐와 스택, 데크의 구현

## 연결 리스트를 통한 구현

- 이 세 가지 자료 구조를 구현하는 가장 간단한 방법은 연결리스트를 사용하는 것입니다.

## 동적 배열을 이용한 구현

> 스택의 경우에는 한쪽 끝에서만 자료의 추가와 삭제가 일어나므로 동적 배열을 곧장 사용할 수 있습니다.


> 하지만 큐와 데크의 경우에는 그렇게 간단하지 않습니다.
- 뒤에서 원소를 추가하거나 삭제하기는 쉽지만 배열의 맨 앞에서 원소를 삭제하기 위해서는 O(n)의 시간이
  걸리기 때문입니다.

> 해결법
- 동적 배열을 이용해 큐나 데크를 구현할 때는 첫 번째 원소와 마지막 원소의 위치를 두 변수 head와
  tail에 유지하면서, 맨 앞에서 원소를 꺼낼 때 뒤에 있는 원소들을 모두 앞으로 옮겨오는 대신 head를
  다음 원소로 옮깁니다.
- 또한 버려지는 공간의 낭비를 막기 위해, 더 이상 원소를 삽입할 곳이 없을 때는 동적 배열을
  재할당합니다.
- 아래 그림과 같이 tail이 배열의 끝에 도달하자 처음으로 다시 돌아와서 원소를 저장하는
  환형버퍼(circular buffer)가 좋은 예입니다.


![img1](/img/2019-12-22-Jongman-ch19-1-1.png)


# 19.3 스택과 큐의 활용

## 예제 : 큐를 이용한 조세푸스 문제의 해법

- 큐의 첫 번째 사람이 나와서 죽고
- 큐의 맨 앞에 있는 사람을 맨 뒤로 보내는 작업을 k-1번 반복한다.

## 예제 : 스택을 이용한 울타리 자르기 문제의 해법

- 울타리 자르기 문제를 7장에서 분할정복으로 풀었었습니다.
- 이번 예제에서는 stack을 이용하여 문제를 풀이합니다.
- 분할정복의 경우 O(NlogN)이 걸리지만, stack을 사용하면 O(N)의 시간복잡도를 가집니다.
- stack을 사용하는 경우는 크게 와닿지가 않습니다.
    - 다른 블로그들도 같이 보며 이해가 필요하다고 생각합니다.

> 어떤 판자를 완전히 포함하는 사각형 중 면적이 최대인 사각형을 해당 판자의 최대 사각형이라고
> 부르도록 합시다.
- 이 사각형의 높이는 i번 판자와 항상 같습니다.
- 이 사각형의 왼쪽 끝과 오른쪽 끝은 i번 판자보다 낮은 판자들로 막혀 있습니다.
- 이 사각형을 막는 판자들의 번호를 각각 left[i], right[i]라고 부릅시다.

![img2](/img/2019-12-22-Jongman-ch19-1-2.png)

> 판자의 넓이를 구하기 위해서는 left[i], right[i]가 필요합니다.
- 넓이 = (right[i] - left[i]-1) * h[i]를 통해 계산할 수 있습니다.


### 스위핑 알고리즘의 설계

> 맨 왼쪽 0번 판자부터 시작해서 순서대로 각 판자를 처리해 가는 스위핑 알고리즘을 설계해 봅시다.
> 아래 과정을 반복하면서 스위핑 알고리즘을 얻을 수 있습니다.
- i번 판자를 봤는데, 왼쪽에 자신보다 높은 판자들이 남아 있다면 그들의 최대 사각형을 자신이 막고
  있음을 알 수 있습니다.
- 이들 전부에 대해 최대 사각형의 넓이를 계산하고 이들을 지워버립니다.
- 그러고 나면 i번 판자 왼쪽에는 자신보다 낮은 판자만이 남아있습니다.
- 그리고 나면 left[i]를 항상 알 수 있습니다.


### 구현

```cpp
이해하는 것이 생각보다 쉽지 않다. 
아래 내용을 참조하자.

for문을 통해 h인덱스를 순서대로 훑어 간다.
- 현재 인덱스 i보다 remaining의 top값이 더 큰 경우 넓이를 구하는 과정을 반복한다.
  - 이때, remaining.top()이 가리키는 인덱스의 높이가 left[]가 되고,
          h[i]가 right가 된다.

- 즉, h의 인덱스를 훑으며 right를 찾으면 넓이를 구하는 것이다.
    - right를 찾는다는 것은 remaining에 있는 top값 보다 작은 높이를 만났을 때이다.
    - 또한 이때, remaining.top에 해당하는 값이 left[]가 될 수 있는 이유는,
      remaining 에는 h[i]보다 높은 높이를 가지는 인덱스는 모두 삭제 되었기 때문에,
      무조건 h[i]보다 낮은 높이를 갖기 때문.

- 정리가 명확하지 않다. 몇 번 더 보면서 확실히 이해하는 게 좋을 것 같다.
```


```cpp
// 각 판자의 높이를 저장하는 배열
vector<int> h;
// 스택을 사용한 O(n) 해법
int solveStack(){
    // 남아 있는 판자들의 위치들을 저장한다.
    stack<int> remaining;
    h.push_back(0);
    int ret = 0;
    for(int i = 0; i < h.size(); ++i){
        // 남아 있는 판자들 중 오른쪽 끝 판자가 h[i]보다 높다면
        // 이 판자의 최대 사각형은 i에서 끝난다.
        while (!remaining.empty() && h[remaining.top()] >= h[i]) {
            int j = remaining.top();
            remaining.pop();
            int width = -1;
            // j번째 판자 왼쪽에 판자가 하나도 안 남아 있는 경우 left[j] = -1,
            // 아닌 경우 left[j] = 남아 있는 판자 중 가장 오른쪽에 있는 판자의 번호
            // 가 된다.
            if(remaining.empty())
                width = i;
            else
                width = (i - remaining.top() -1);
            ret = max(ret, h[j] * width);
        }
        remaining.push(i);
    }
    return ret;
}
```
