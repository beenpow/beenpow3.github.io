---
title : Ch.18.1 선형 자료 구조

categories:
- jongman

tags:
- jongman
---

# 18.1 선형 자료 구조

- 일렬로 늘어선 같은 종류의 자료 여러 개를 저장하기 위한 가장 기초적인 자료 구조는 배열입니다.

## 동적 배열

- 배열의 큰 문제 중 하나는 처음에 배열을 선언할 때 배열의 크기를 지정해야 하며, 그 이상의 자료를
  집어넣을 수 없다는 점입니다.
- 이와 같은 문제를 해결하기 위해 고안된 것이 자료의 개수가 변함에 따라 크기가 변경되는 동적
  배열(dynamic array)입니다.

> 배열의 특성
- 원소들은 메모리의 연속된 위치에 저장됩니다.
- 주어진 위치의 원소를 반환하거나 변경하는 동작을 O(1)에 할 수 있습니다.


> 동적 배열의 특성
- 배열의 크기를 변경하는 resize()연산이 가능합니다.
    - 이 동작을 수행하는 데는 배열의 크기 N에 비례하는 시간이 걸립니다.
- 주어진 원소를 배열의 맨 끝에 추가함으로써 크기를 1 늘리는 append()연산을 지원합니다.
    - 이 동작을 수행하는 데는 상수 시간이 걸립니다.
- 동적배열은 할당받은 메모리의 크기를 배열의 용량(capacity), 그리고 실제 원소의 수를 배열의
  크기(size)라 합니다.
- 동적 배열의 append연산은 호출될때마다 resize()를 호출해서 append()의 수행 시간도 선형이 되어
  버립니다.
- 이를 해결하기 위해, append 연산 수행시 더 큰 capacity를 가지는 배열을 할당하고 기존의 배열의
  내용을 모두 복사한 다음 배열에 대한 포인터를 바꿔치기 합니다.
  - 이 과정은 재할당이라고 하며, 아래와 같이 이루어 집니다.


```cpp
// 배열 용량이 꽉 찼으면 재할당받는다.
if(size == capacity){
    // 용량을 M만큼 늘린 새 배열을 할당받는다.
    int newCapacity = capacity + M;
    int* newArray = new int[newCapacity];
    // 기존의 자료를 복사한다.
    for(int i = 0; i < size; i++)
        newArray[i] = array[i];
    // 기존 배열을 삭제하고, 새 배열로 바꿔치기 한다.
    if(array) delete [] array;
    array = newArray;
    capacity = newCapacity;
}
// 배열의 끝에 원소를 삽입한다.
array[size++] = newValue;
```
- 재할당 과정에 드는 시간은 O(N+M)이 소요됩니다.

# 18.3 연결 리스트

- 연결 리스트는 특정 위치에서의 삽입과 삭제를 상수 시간에 할 수 있게 해 줍니다.
- 배열에서는 메모리의 연속된 위치에 각 원소들이 저장되어 있다며, 연결 리스트는 원소들이 메모리 여기
  저기 흩어져 있고 각 원소들이 이전과 다음 원소를 가리키는 포인터를 가지고 있는 방식으로 구현됩니다.

```cpp
struct ListNode{
    int element; // 담고 있는 원소
    ListNode *prev, *next; // 이전 노드, 다음 노드의 포인터 
}
```

## 연결리스트 응용 연산들

### 잘라 붙이기 연산

- 연결 리스트에서 노드들 간의 포인터만을 변경해 원소의 삭제와 삽입을 상수 시간에 할 수 있었던 것을
  응용하면 다른 리스트를 통째로 삽입하는 것 또한 상수 시간에 할 수 있습니다.
- 이와 같은 연산을 잘라붙이기(splicing)라고 부릅니다.

### 삭제 했던 원소 돌려놓기

- 양방향 연결 리스트의 잘 알려지지 않은 장점으로, 한 번 삭제했던 원소를 제 자리에 쉽게 돌려 놓을 수
  있다는 것이 있습니다.

```cpp
// node 이전/이후 노드의 포인터를 바꿔서 node를 리스트에서 삭제한다.
void deleteNode(ListNode* node){
    node->prev->next = node->next;
    node->next->prev = node->prev;
}
// node 이전/이후 노드의 포인터를 바꿔서 자기 자신을 다시 리스트에 삽입한다.
void recoverNode(ListNode* node){
    node->prev->next = node;
    node->next->prev = node;
}
```

- 이때 우리가 바꾼 것은 node의 이전/이후 노드의 포인터 뿐으로, node에 들어있는 정보는 변하지
  않았습니다.

# 18.4 동적 배열과 연결 리스트의 비교

|작업 | 동적 배열 | 연결리스트 |
|-----|-----------|------------|
|이전 원소/다음 원소 찾기| O(1)|O(1)|
|맨 뒤에 원소 추가/삭제하기|O(1)|O(1)|
|맨 뒤 이외의 위치에 원소 추가/삭제하기| O(n)|O(1)|
|임의의 위치의 원소 찾기|O(1)|O(n)|
|크기 구하기|O(1)|O(n)혹은 구현에 따라 O(1)|


