---
title : Ch.21.1 트리의 구현과 순회

categories:
- jongman

tags:
- jongman
---

# 21.1 도입

## 정의

- 트리 : 계층적 구조를 갖는 자료들을 표현하기 위한 자료 구조


## 기초적인 정의와 용어

### 트리의 구성 요소

- 트리는 자료가 저장된 노드(node)들이 간선(edge)으로, 서로 연결되어 있는 자료 구조를 말합니다.
- 두 연결된 노드 중
    - 상위 노드를 부모(parent)노드
    - 하위 노드를 자식(child)노드
- 부모 노드가 같은 두 노드는 형제(sibling)노드
- 부모 노드와 그의 부모들을 통틀어 선조(ancestor)
- 자식 노드와 그의 자식들을 통틀어 자손(decendant)
- 트리에는 다른 모든 노드들을 자손으로 갖는 딱 하나의 노드가 있는데, 이를 뿌리 노드 혹은 root라고
  부릅니다.
- 반대로 자식이 하나도 없는 노드들은 트리의 잎 노드 혹은 리프(leaf)라고 부릅니다.

### 트리와 노드의 속성

- 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수를 해당 노드의 깊이(depth)라고 부릅니다.
- 이때 가장 깊숙이 있는 노드의 깊이를 해당 트리의 높이(height)라고 합니다.

### 트리의 재귀적 속성

- 어떤 노드 t와 그 자손들로 구성된 트리를 't를 루트로 하는 서브트리(subtree)' 라고 말합니다.
- 따라서 모든 트리는 루트와 루트 밑에 있는 서브트리들의 집합이라고 말할 수 있습니다.
- 이와 같은 재귀적 속성 때문에 트리를 다루는 코드들은 대게 재귀 호출을 이용해 구현됩니다.

### 트리의 표현

- 트리의 가장 일반적인 형태로의 표현은 각 노드를 하나의 구조체/객체로 표현하고, 이들을 서로의
  포인터로 연결하는 것입니다.
  - 이때 각 노드들은 자신의 부모와 모든 자손들에 대한 포인터를 가지고 있습니다.

```cpp
struct TreeNode{
    string label; // 저장할 자료(물론 꼭 문자열일 필요는 없다.)
    TreeNode* parent; // 부모 노드를 가리키는 포인터
    vector<TreeNode*> children; // 자손 노드들을 가리키는 포인터의 배열
};
```

# 21.2 트리의 순회

- 모든 트리는 각 자식들을 루트로 하는 서브트리와 루트로 나눌 수 있으므로, 트리의 루트가 주어질 때
  루트를 '방문'한 뒤 각 서브트리를 재귀적으로 방문하는 함수를 만들어 트리의 모든 노드를 순회할 수
  있습니다.


```cpp
// 주어진 트리의 각 노드에 저장된 값을 모두 출력한다.
void printLables(TreeNode* root){
    // 루트에 저장된 값을 출력한다.
    cout << root->label << enld;
    // 각 자손들을 루트로 하는 서브트리에 포함된 값들을 재귀적으로 출력한다.
    for(int i = 0; i < root->children.size(); i++){
        printLabels(root->children[i]);
    }
}
```

- 순회의 또 다른 사용 예로 트리의 높이를 구하는 문제가 있습니다.
- 루트의 각 자식들을 루트로 하는 서브트리들의 높이를 각각 재귀 호출을 통해 계산합니다.
- 그러면 전체 트리의 높이는 그중 최대치에 1을 더한 것입니다.

```cpp
// root를 루트로 하는 트리의 높이를 구한다.
int height(TreeNode* root){
    int h = 0;
    for(int i = 0; i < root->children.size(); i++){
        h = max(h, 1 + height(root->children[i]));
    }
}
```

- 트리에 n개의 노드가 있다고 가정하면 순회에는 O(n)의 시간이 소모됩니다.

