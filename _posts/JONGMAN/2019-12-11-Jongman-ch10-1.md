---
title : Ch.10.1 문제 ID  MATCHORDER

categories:
- jongman

tags:
- jongman
---

# 10.1 문제: 출전 순서 정하기 ( 문제ID : MATCHORDER, 난이도: 하)
[algo]: <https://algospot.com/judge/submission/recent/>
- 알고리즘 분류 : 탐욕법
- 실제 코드의 구현은 복잡하지 않지만,
- 중요한 것은 정당함을 증명하는 것이라 생각합니다.
- 정당화 시켜가는 증명법을 유심히 살펴보는 것이 좋다고 생각합니다.


## 무식하게 풀 수 있을까?

- n 명의 선수가 있으니 이 문제에는 n!개의 답이 있습니다.

## 그렇다면 동적 계획법은 어떨까?

> order(taken) = 각 한국팀 선수를 이미 순서에 추가했는지의 여부가 taken에 주어질 때, 남은 선수들을
>                적절히 배치해서 얻을 수 있는 최대 승수

- taken에 포함된 true의 수를 세면 이번에 선택할 선수가 러시아팀의 어떤 선수와 경기하게 되는지도 알
  수 있으니, taken외에 다른 인자는 필요가 없습니다.
- O(n * 2^n)시간의 동적 계획법 알고리즘을 얻을 수 있습니다.

## 탐욕법

### 탐욕적 알고리즘의 구상

- 맨 앞 경기부터 한 명씩 출전할 한국 선수를 정하도록 합시다.
- 상대방 선수를 이길 수 있는(레이팅이 같거나 높은) 한국 선수가 있는 경우 그중 레이팅이 가장 낮은
  선수를 상대방 선수와 경기십니다.
- 만약 상대방 선수가 한국팀의 모든 선수보다 레이팅이 높다면 남은 선수 중 가장 레이팅이 낮은 선수와
  경기시킵니다.
- 이와 같은 방법으로 예제 입력에 적용해 봅시다.
- 다섯 경기를 이길 수 있습니다.

### 탐욕적 선택 속성 증명

> 이 방법의 정당성을 증명하기 위해, 항상 우리가 하는 선택을 포함하는 최적해가 존재함을 증명합시다.
- 각 경기에 대해 이 경기를 질 수밖에 없는 경우, 그리고 이 경기를 이길 수 있는 경우로 나눠 우리의
  선택이 옳다는 것을 보이겠습니다.

> 먼저 이 경기를 질 수밖에 없는 경우를 고려해 봅시다.
- 상대팀 선수가 모든 우리 팀 선수보다 레이팅이 높을 경우, 이 경기는 항상 질 수밖에 없습니다.
- 이 경기에 가장 레이팅이 낮은 선수 A대신 선수 B를 내보내서 최적해가 있다고 가정합시다.
- 이를 다음 그림처럼 표현할 수 있습니다.

![img1](/img/2019-12-11-Jongman-ch10-1-1.png)

- 최적해에서 이 두 선수의 순서를 바꾸면 어떻게 될까요?
- 이번 경기는 어차피 질 테지만, A를 상대했던 선수 x는 레이팅이 더 높은 선수를 상대하게 됩니다.
- 따라서 승수가 더 줄어들 일은 없고, 이 경기에 A를 내보내는 최적해가 존재함을 알게 됩니다.


> 다음으로 이 경기를 이길 수 있는 경우를 고려합시다.
- 상대팀 선수보다 레이팅이 높거나 같은 우리 선수가 있다면 이 경기를 승리할 수 있습니다.
- 승리할 수 있는 선수 중 레이팅이 낮은  A 대신 레이팅이 더 높은 B를 내보내는 최적해가 있다고
  가정합시다.
- 다음과 같은 형태를 갖게 되지요.

![img2](/img/2019-12-11-Jongman-ch10-1-2.png)

- 이 최적해에서 A와 B의 위치를 바꿔봅시다.
- 이번 경기는 어차피 승리할 테고, A를 상대했던 x는 레이팅이 더 높은 선수를 상대하게 됩니다.
- 같은 전개로 이 순서 또한 최적해임을 알 수 있습니다.
- 반대로 선수  A보다 레이팅이 더 낮은 선수를 내보내야 할 경우가 있을까요?
- A 대신 레이팅이 더 낮은 C를 내보내는 최적해가 있다고 가정합시다.
- 그러면 이 경기는 이길 수 있지만 지게 됩니다.
- 이 최적해에서  A와 C의 위치를 바꾸면 이 경기는 승리로 바뀝니다.
- A가 했던 경기는 C가 대신 해서 질 수도 있겠지만, 승수가 1늘고 1줄었으니 결과적으로는 최적해지요.

- 이렇게 두 경우 모두 우리의 선택은 최다승을 보장한다는 사실을 알 수 있습니다.

### 최적 부분 구조 증명

- 첫번째 경기에 나갈 선수를 선택하고 나면 남은 선수들을 경기에 배정하는 부분 문제를 얻을 수
  있습니다.
- 이때 남은 경기에서도 당연히 최다승을 얻는 것이 좋으니 최적 부분 구조도 자명하게 성립함을 알 수
  있습니다.

### 구현

- 아직 출전하지 않은 선수들의 레이팅을 이진 검색 트리인 multiset<int>에 저장합니다.
- 이로 인해 이길 수 있는 가장 레이팅이 낮은 선수를 찾는 작업과 선택한 선수의 레이팅을 삭제하는 작업
  등을 모두 O(logn)에 수행할 수 있습니다.
- 따라서 전체 시간 복잡도는 O(nlogn)이 됩니다.

```cpp
int order(vector<int>& russian, vector<int>& korean){
    int n = (int)russian.size(), wins = 0;
    // 아직 남아 있는 선수들의 레이팅
    multiset<int> ratings(korean.begin(), korean.end());
    for(int rus = 0; rus < n; rus++){
        // 가장 레이팅이 높은 한국 선수가 이길 수 없는 경우
        // 가장 레이팅이 낮은 선수와 경기시킨다.
        if(*ratings.rbegin() < russian[rus]){
            ratings.erase(ratings.begin());
            // 이 외의 경우 이길 수 있는 선수 중 가장 레이팅이 낮은 선수와 겨이시킨다.
        }else{
            ratings.erase(ratings.lower_bound(russian[rus]));
            ++wins;
        }
    }
    return wins;
}
```



## 탐욕적 알고리즘 레시피

```cpp
1. 문제의 답을 만드는 과정을 여러 조각으로 나눕니다.

2. 각 조각마다 어떤 우선순위로 선택을 내려야 할지 결정합니다. 이에 대한 직관을 얻기 위해서는 예제
   입력이나 그 외의 작은 입력을 몇 개 손으로 풀어보는 것이 효율적입니다.

3. 어떤 방식이 동작할 것 같으면 두 가지의 속성을 증명해 봅니다.
    
    a) 탐욕적 선택 속성 : 항상 각 단계에서 우리가 선택한 답을 포함하는 최적해가 존재함을 보이면
    됩니다. 이 증명은 대개 우리가 선택한 답과 다른 최적해가 존재함을 가정하고, 이것을 조작해서
    우리가 선택한 답을 포함하는 최적해로 바꿀 수 있음을 보이는 형태로 이루어집니다.

    b) 최적 부분 구조: 각 단계에서 항상 최적의 선택만을 했을 때 전체 최적해를 구할 수 있는 지 여부를
    증명합니다. 다행히도 대개의 경우 이 속성이 성립하는지 아닌지는 자명하게 알 수 있습니다.
```
