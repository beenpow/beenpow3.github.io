---
title : Ch.25.1 상호 배타적 집합

categories:
- jongman

tags:
- jongman
---

# 25.1 도입

- 또 다른 형태의 독특한 트리로 상호 배타적 집합(disjoint set)을 표현할 때 쓰는
  유니온-파인드(Union-Find) 자료 구조가 있습니다.

## 상호 배타적 집합

- n명이 인원이 모인 곳에서, 생일이 같은 사람끼리 팀을 구성하라고 했다고 합시다.
    - 각 팀은 생일이 같은 사람들로 구성되었기 때문에, 두 개 이상의 팀에 속한 사람은 없다는 점을
      유의합시다.
    - 이렇게 공통 원소가 없는, 다시 말해 상호 배타적인 부분 집합들로 나눠진 원소들에 대한 정보를
      저장하고 조작하는 자료 구조가 바로 유니온-파인드 자료 구조입니다.

> 필요한 세 가지 연산
- 초기화: n개의 원소가 각각의 집합에 포함되어 있도록 초기화합니다.
- 합치기(union) 연산 : 두 원소 a,b가 주어질 때 이들이 속한 두 집합을 하나로 합칩니다.
- 찾기(find) 연산 : 어떤 원소 a가 주어질 때 이 원소가 속한 집합을 반환합니다.

## 배열로 상호 배타적 집합 표현하기

- 상호 배타적 집합을 표현하는 가장 간단한 방법은 1차원 배열 하나를 이용하는 것입니다.

```cpp
belongsTo[i] = i번 원소가 속하는 집합의 번호
```
- 찾기 연산은 O(1)에 가능
- 합치기 연산은 O(n) 시간 소모
    - 한 쪽의 모든 원소를 순회하며 다른 쪽 집합으로 옮겨주어야 하기 때문입니다.

## 트리를 이용한 상호 배타적 집합의 표현

- 이 표현에서는 한 집합에 속하는 원소들을 하나의 트리로 묶어 줍니다.
- 두 원소가 같은 트리에 속해 있는지 확인하는 가장 직관적인 방법은 각 원소가 포함된 트리의 루트를
  찾은 뒤 이들이 같은지 비교하는 것입니다.
- 따라서 트리의 루트에 있는 원소를 각 집합의 대표라고 부릅시다.
- 이와 같이 트리를 이용한 집합 표현에서는 두 원소가 포함된 집합을 합치기도 아주 간단합니다.
    - 각 트리의 루트를 찾은 뒤, 하나를 다른 한쪽의 자손으로 넣으면 되지요.

![img1](/img/2019-12-31-Jongman-ch25-1-1.png)

```cpp
// 트리를 이용해 상호 배타적 집합을 구현한다.
struct NaiveDisjointSet{
    vector<int> parent;
    NaiveDisjointSet(int n): parent(n){
        for(int i = 0; i < n; ++i)
            parent[i] = i;
    }
    // u가 속한 트리의 루트의 번호를 반환한다.
    int find(int u) const{
        if(u == parent[u]) return u;
        return find(parent[u]);
    }
    // u가 속한 트리와 v가 속한 트리를 합친다.
    void merge(int u, int v){
        u = find(u); v = find(v);
        // u와 v가 이미 같은 트리에 속하는 경우를 걸러낸다.
        if(u == v)return;
        parent[u] = v;
    }
};
```

## 상호 배타적 집합의 최적화

- 상호 배타적 트리도, 트리를 사용하므로 연산의 순서에 따라 잘못하면 트리가 한쪽으로 기울어질 수 있다는 문제를 피해갈 수 없습니다.
- 이 경우 찾기 연산도 합치기 연산도 O(n)이 되어버립니다.(높이가 n이므로)

> 쉽게 생각할 수 있는 방법은 두 트리를 합칠 때
- 항상 높이가 더 낮은 트리를 더 높은 트리 밑에 집어넣음으로써 트리의 높이가 높아지는 상황을 방지하는
  것입니다.
- 이 최적화를 랭크에 의한 합치기(union-by-rank) 최적화 라고 부릅니다.


- 이해를 돕기 위해 설명을 덧붙이자면,
    - 그림(a)를 기준으로 NaiveDisjointSet을 통해 merge(2, 4)을 이용한 경우가 그림 (b)입니다.
    - 그림(a)를 기준으로 NaiveDisjointSet을 통해 merge(4, 2)를 한 경우 아래 그림과 같이 불균형 해집니다.
        - 이 경우 OptimizedDisjointSet을 이용한다면 rank의 높이가 낮은 2가 4쪽으로 합쳐지며,
          결과적으로 rank[4]에 대한 높이변화는 없는 것을 알 수 있습니다.
    - 또한 rank의 높이가 같은 경우엔 root가 되는 쪽의 rank만 1늘려 주면 되는 것도 생각해낼 수
      있습니다.


![img2](/img/2019-12-31-Jongman-ch25-1-2.png)

```cpp
// 트리를 이용해 상호 배제적 집합을 구현한다.
struct OptimizedDisjointSet{
  vector<int> parent, rank;
  OptimizedDisjointSet(int n): parent(n), rank(n, 1){
    for(int i = 0; i < n; i++)
        parent[i] = i;
  }
  // u가 속한 트리의 루트의 번호를 반환한다.
  int find(int u){
    if(u == parent[u]) return u;
    return parent[u] = find(parent[u]);
  }
  // u가 속한 트리와 v가 속한 트리를 합친다.
  void merge(int u, int v){
    u = find(u); v = find(v);
    // u와 v가 이미 같은 집합에 속하는 경우를 걸러낸다.
    if(u == v) return;
    if(rank[u] > rank[v]) swap(u,v);
    // 이제 rank[v]가 항상 rank[u] 이상이므로 u를 v의 자식으로 넣는다.
    parent[u] = v;
    if(rank[u] == rank[v]) ++rank[v];
  }
};
```

## 경로 압축(path compression) 최적화

- 많은 경우에는 이와 같은 최적화만으로도 충분합니다만, 간단하면서도 아주 큰 효과가 있는 또 다른
  최적화가 있습니다.
- 이 최적화는 찾기 연산이 중복된 계산을 여러 번 하고 있다는 데 착안합니다.
    - find(u)를 통해 u가 속하는 트리의 루트를 찾아냈다고 합시다.
    - 이때 parent[u]를 찾아낸 루트로 아예 바꿔 버리면 다음번에 find(u)가 호출되었을 때는 경로를 따라
      올라갈 것 없이 바로 루트를 찾을 수 있겠지요.

- 그림 (b)는 그림 (a)의 트리에서 find(0)을 수행한 결과를 보여줍니다.
- 0에서 루트까지 올라가는 경로에 있던 다른 노드 2, 3도 루트에 직접 연결되어 있음을 볼 수 있습니다.


![img3](/img/2019-12-31-Jongman-ch25-1-3.png)

## 예제

### 예제 : 그래프의 연결성 확인하기
- 31장에서 다루는 크루스칼의 최소 스패닝 트리 알고리즘이 상호 배타적 집합을 이용해 이와 같은 문제를
  해결하는 대표적 사례입니다.

### 예제 : 가장 큰 집합 추적하기

- 상호 배타적 집합은 단순히 두 원소가 같은 집합에 속해 있는지를 확인하는 것 외에도 다른 일을 할 수
  있습니다.
  - 예를 들어 각 집합에 속한 원소의 수를 추적할 수 있습니다.
  - rank[]처럼 각 트리의 노드의 개수를 담는 배열 size[]를 추가한 뒤 두 집합이 합쳐질 때마다 이 값을
    갱신해주면 됩니다.
