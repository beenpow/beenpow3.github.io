---
title : Ch.28.7 이론적 배경과 응용

categories:
- jongman

tags:
- jongman
---

# 이론적 배경과 응용

- 깊이 우선 탐색의 +a 버전이라고 생각합니다.

## 깊이 우선 탐색과 간선의 분류

- 그래프의 간선들을 분류하면 그래프의 구조에 대해 많은 것을 배울 수 있습니다.

![img1](/img/2020-01-01-Jongman-ch28-7-1.png)

- 그림 (a)의 그래프를 0번 정점에서부터 깊이 우선 탐색했을 때 탐색이 따라가는 간선들을 굵은 실선으로
  표시하면 그림 (b)를 얻을 수 있습니다.
- 굵은 실선이 0번 정점을 루트로 하는 트리 형태를 띠는 것을 볼 수 있습니다.
> 이런 트리를 주어진 그래프의 깊이 우선 탐색 스패닝 혹은 DFS 스패닝 트리(DFS Spanning Tree)라고
> 부릅니다.


- 그래프의 DFS 스패닝 트리를 생성하고 나면 그래프의 모든 간선을 다음과 같이 네 가지 중 하나로 분류할
  수 있습니다.
  - 트리 간선(tree edge)
    - 스패닝 트리에 포함된 간선을 의미합니다.
    - 그림 (b)에서 굵은 선으로 표시된 간선들이 모두 트리 간선입니다.
  - 순방향 간선(forward edge)
    - 스패닝 트리의 선조에서 자손으로 연결되지만 트리 간선이 아닌 간선을 말합니다.
    - 그림 (b)의 (0, 6) 간선이 순방향 간선의 예입니다.
  - 역방향 간선(back edge)
    - 스패닝 트리의 자손에서 선조로 연결되는 간선을 말합니다.
    - 그림 (b)의 (2, 0) 같은 간선이 역방향 간선의 예입니다.
  - 교차 간선(cross edge)
    - 위의 세 가지 분류를 제외한 나머지 간선들을 의미합니다.
    - 교차 간선은 트리에서 선조와 자손 관계가 아닌 정점들 간에 연결된 간선들을 의미합니다.
    - 그림 (b)에서 (6, 3) 같은 간선이 교차 간선의 예입니다.


## 간선 분류의 예
- 그래프를 그림으로 그려놓고, 깊이 우선 방문 탐색을 진행하며 
  - 최초 방문한 지점은 "트리 간선"
  - 스패닝 트리의 한 노드에서 선조로 가는 간선은 "역행 간선"
  - 스패닝 트리의 한 노드에서 후손으로 가는 간선은 "순방향 간선"(트리 간선 제외)
  - 서로 조상도 후손도 아닌 간선을 "교차 간선"
- 으로 구별해갈 수 있습니다.


## 무향 그래프 간선의 분류

- 무향 그래프의 모든 간선은 양방향으로 통행 가능하므로, 무향 그래프에는 교차 간선이 있을 수
  없습니다.
- 또한 무향 그래프의 경우 순방향 간선과 역방향 간선의 구분이 없다는 점도 유념해야 합니다.

## 예제: 위상 정렬의 정당성 증명

- 간선의 분류는 그 자체가 유용하다기보다는 그래프 알고리즘을 이해하고 증명하기 위한 도구로 유용하게
  쓰입니다.
- 이를 이용해 위상 정렬의 정당성을 증명해 보겠습니다.
  - 참고로 위상 정렬이 시사하는 아래 fact에 대해 정당성을 증명합니다.
  - dfsAll()을 수행하며 dfs()가 종료할 때마다 현재 정점의 번호를 기록하고,
  - dfsAll()이 종료한 뒤 기록된 순서를 뒤집으면 위상 정렬 결과를 얻을 수 있습니다.
  - 따라서 dfs()가 늦게 종료한 정점일수록 정렬 결과의 앞에 옵니다.
- 우리의 위상 정렬 알고리즘은 dfs()의 종료 역순으로 정점을 배열하므로, dfs(u)가 dfs(v)보다 일찍
  종료할 경우 u에서 v로 가는 간선이 존재할 수 없다는 것만 증명하면 그 정당성을 보일 수 있습니다.
  - 이를 위해 (u, v) 간선이 4가지 종류의 간선인 모든 경우에 대해 증명합니다.
- (u, v)가 트리 간선이라면,
  - dfs(u)에서 dfs(v)를 호출 했다는 말인데, 그러면 dfs(u)가 먼저 종료할 수 없습니다.
- (u, v)가 역방향 간선이라면,
  - v가 u의 선조이므로 v에서 u로 가는 경로가 있다는 뜻인데, 여기에 (u,v)를 붙이면 사이클이 되므로
    그래프가 DAG라는 가정에 모순됩니다.
- (u, v)가 순방향 간선이라면,
  - u가 v의 선조라는 뜻인데, 이때 dfs(u)가 먼저 종료하는 것은 불가능합니다.
- (u, v)가 교차 간선이라면,
  - dfs(v)가 종료하고 나서 u를 방문했다는 뜻인데, 이것은 dfs(u)가 먼저 종료했다는 것과 모순입니다.

- 따라서 이와 같은 간선 (u,v)는 존재할 수 없고, 위상 정렬의 정당성은 증명됩니다.
 
## 예제: 사이클 존재 여부 확인하기

- 간선 구분의 또 다른 사용 예로 방향 그래프에 사이클이 존재하는지 여부를 판정하는 문제를 들 수
  있습니다.
- 간선의 분류를 이용하면 이 문제를 아주 쉽게 풀 수 있습니다.
> 사이클의 존재여부는 역방향 간선의 존재 여부와 동치이기 때문입니다.
  - 사이클에 포함된 정점 중 깊이 우선 탐색 과정에서 처음 만나는 정점을 u라고 합시다.
  - dfs(u)는 u에서 갈 수 있는 정점들을 모두 방문한 후에 종료할 겁니다.
  - 따라서 깊이 우선 탐색은 사이클에서 u 이전에 있는 정점을 dfs(u)가 종료하기 전에 방문하게 되는데,
    그러면 이 정점에서 u로 가는 정점은 항상 역방향 간선이 됩니다.

```cpp
vector<vector<int>> v;
// 방문된 상태에서는 1, 방문 종료된 이후에는 0을 갖습니다.
vector<int> visit;
// 이미 방문한 곳은 1, 한번도 방문하지 않은 곳은 0을 갖습니다.
vector<int> check;
int dfs(int u) {
    // 이미 방문 상태가 1인 곳을 재 방문한다는 것은 사이클이 있다는 의미입니다.
    if (visit[u]) return 1;
    if (check[u]) return 0;
    check[u] = 1;
    visit[u] = 1;
    for (int i = 0; i < v[u].size(); i++) {
        if (dfs(v[u][i])) return 1;
    }
    visit[u] = 0;
    return 0;
}
```

## 간선을 구분하는 방법

- 트리 간선
  - dfs(u) 내에서 간선 (u,v)를 검사했을 때 v가 방문된 적이 없다면 이 간선을 따라가므로 (u,v)는 트리
    간선이 됩니다.
- (u,v)가 순방향 간선이라면
  - v는 u의 자손이어야 합니다.
  - 따라서 v는 u보다 더 늦게 발견되어야 합니다.
- (u,v)가 역방향 간선이려면
  - v는 u의 선조여야 합니다.
  - 따라서 v는 u보다 일찍 발견되었어야 합니다.
- (u,v)가 교차 간선이려면
  - dfs(v)가 종료한 후 dfs(u)가 호출되어야 합니다.
  - 따라서 v는 u보다 일찍 발견되었어야 합니다.

- 반면 v가 u보다 먼저 방문되었다면 v가 u의 부모인지 아닌지를 구분할 방법이 없습니다.
  - 이와 같은 경우를 구분하는 한 가지 방법은 dfs(u)가 종료했는지를 확인하는 것입니다.
  - dfs(v)가 아직 종료하지 않았다면 v는 u의 선조이니 (u,v)는 역방향 간선이 되고, 아니면 교차 간선이
    됩니다.

```cpp
// 그래프의 인접 리스트 표현 
vector<vector<int> > adj;
// discovered[i] = i번 정점의 발견 순서
// finished[i] = dfs(i)가 종료했으면 1, 아니면 0
vector<int> discovered, finished;
// 지금까지 발견한 정점의 수
int counter;
void dfs2(int here){
    discovered[here] = counter++;
    // 모든 인접 정점을 순회하면서
    for(int i = 0; i < adj[here].size(); i++){
        int there = adj[here][i];
        cout << "(" << here << "," << there << ") is a ";
        // 아직 방문한 적 없다면 방문한다.
        if(discovered[there] == -1){
            cout << "tree edge" << endl;
            dfs2(there);
        }
        // 만약 there가 here보다 늦게 발견됐으면 there는 here의 후손이다.
        else if(discovered[here] < discovered[there])
            cout << "forward edge" << endl;
        // 만약 dfs2(there)가 아직 종료하지 않았으면 there는 here의 선조다.
        else if(finished[there] == 0)
            cout << "back edge" << endl;
        // 이외의 경우는 모두 교차 간선
        else
            cout << "cross edge" << endl;
    }
    finished[here] = 1;
    }
}
```
## 예제: 절단점 찾기 알고리즘

- 깊이 우선 탐색을 이용해 그래프의 절단점(cut vertex)을 찾는 문제가 있습니다.
> 어떤 무향 그래프의 절단점이란 이 점과 인접한 간선들을 모두 지웠을 때 해당 컴포넌트가 두 개
> 이상으로 나뉘어지는 정점을 말합니다.
- 예를 들어, 아래 그림에서 1번, 3번, 5번 정점이 각각 절단점이 됩니다.

![img2](/img/2020-01-01-Jongman-ch28-7-2.png)

> 어떤 정점이 절단점인지 확인하는 간단한 방법은 해당 정점을 그래프에서 삭제한 뒤, 컴포넌트의 개수가
> 이전보다 늘어났는지를 확인하는 것입니다.
- 한 번의 깊이 우선 탐색만으로 그래프의 모든 절단점을 찾아낼 수 있습니다.

- 임의 정점에서부터 깊이 우선 탐색을 수행해 DFS스패닝 트리를 만듭시다.
- 이때 어떤 정점 u가 절단점인지를 어떻게 알 수 있을까요?
  - 무향 그래프의 스패닝 트리에는 교차 간선이 없으므로, u와 연결된 정점들은 모두 u의 선조 아니면
    자손입니다. ( 아래 그림 참조 )

![img3](/img/2020-01-01-Jongman-ch28-7-3.png)

- u가 지워졌을 때 그래프가 쪼개지지 않는 유일한 경우는 그림에 그려진 것처럼 u의 선조와 자손들이 전부
  역방향 가넌으로 연결되어 있을때 뿐입니다.
> 만약 u의 자손들이 모두 역방향 간선을 통해 u의 선조로 올라갈 수 있다면 u는 절단점이 아닙니다.

- u가 스패닝 트리의 루트라서 선조가 없는 경우
  - 자손이 하나도 없거나 하나 밖에 없는 경우
    - 이 경우엔 u는 절단점이 되지 않습니다.
  - 이외의 경우(u가 루트인 경우 둘 이상의 자손을 가질 때만)는 모두 절단점

> 아래 코드에서 우리가 결국 알고 싶은 것은 해당 서브트리가 u의 조상 중 하나와 연결되어 있는지
> 입니다.
- u의 조상들은 항상 u보다 먼저 발견되었겠지요.
- 따라서 깊이 우선 탐색 함수가 해당 정점을 루트로 하는 서브트리에서 역방향 간선을 통해 닿는 정점들의
  최초 발견 순서를 반환하도록 하기만 하면 됩니다.


```cpp
// 그래프의 인접 리스트 표현
vector<vector<int> > adj;
// 각 정점의 발견 순서. -1로 초기화한다.
vector<int> discovered;
// 각 정점이 절단점인지 여부를 저장한다. false로 초기화한다.
vector<bool> isCutVertex;
int counter = 0;
// here를 루트로 하는 서브트리에 있는 절단점들을 찾는다.
// 반환 값은 해당 서브트리에서 역방향 간선이 갈 수 있는 정점 중
// 가장 일찍 발견된 정점의 발견 시점. 처음 호출할 때는 isRoot=true로 둔다.
int findCutVertex(int here, bool isRoot){
    // 발견 순서를 기록한다.
    discovered[here] = counter++;
    int ret = discovered[here];
    // 루트인 경우의 절단점 판정을 위해 자손 서브트리의 개수를 센다.
    int children = 0;
    for(int i = 0; i < adj[here].size(); ++i){
        int there = adj[here][i];
        if(discovered[there] == -1){
            ++children;
            // 이 서브트리에서 갈 수 있는 가장 높은 정점의 번호
            int subtree = findCutVertex(there, false);
            // 그 노드가 자기 자신 이하에 있다면 현재 위치는 절단점!
            if(!isRoot && subtree >= discovered[here])
                isCutVertex[here] = true;
            ret = min(ret, subtree);
        }
        else
            ret = min(ret, discovered[there]);
    }
    // 루트인 경우 절단점 판정은 서브트리의 개수로 한다.
    if(isRoot) isCutVertex[here] = (children >= 2);
    return ret;
}
```
> 무향 그래프에서 절단점을 포함하지 않는 서브그래프를 이중 결합 컴포넌트(biconnected component)라고
> 부릅니다.
- 이중 결합 컴포넌트 내에서는 임의의 한 정점을 그래프에서 지우더라도 정점 간의 연결 관계가
  유지됩니다.


## 예제: 다리 찾기(절단점 찾기와 비슷)

- 절단점을 찾는 문제와 비슷하지만 약간 다른 것으로 그래프에서 다리를 찾는 문제가 있습니다.
> 어떤 간선을 삭제했을 때 이 간선을 포함하던 컴포넌트가 두 개의 컴포넌트로 쪼개질 경우 이 간선을
> 다리(bridge)라고 부릅니다.
- 절단점 찾기 알고리즘 챕터의 첫번째 그림에서, 네 개의 간선 (0,1), (3,4), (5,6), (5,7)이 다리가
  됩니다.

- 가장 먼저 깨달아야 할 점은 다리는 항상 트리 간선일 수밖에 없다는 것입니다.
- 어떤 간선 (u,v)가 순방향 간선이나 역방향 간선이라면 u와 v를 잇는 또 다른 경로가 있다는 것인데,
  그러면 (u,v)는 결코 다리가 될 수 없습니다.
  - 따라서 트리 간선들에 대해서만 이 간선이 다리인지를 판정하면 됩니다.

- 덧붙이자면
  - DFS 스패닝 트리 상에서 u가 v의 부모일 때, 트리 간선(u,v)가 다리가 되기 위해서는 v를 루트로 하는
    서브트리와 이 외의 점들을 연결하는 유일한 간선이 (u,v)이어야 합니다.
    - 즉, (u,v)를 제외한 역방향 간선으로 u보다 높은 정점에 갈 수 없을 경우 (u,v)가 다리라고 판정할
      수 있습니다.

## 예제: 강결합 컴포넌트 분리

- 무향 그래프에서의 이중 결합 컴포넌트의 개념과 비슷한 개념입니다.
- 다시 리마인드 하며, 강결합 컴포넌트와 정리하자면 아래와 같습니다.
  - 무향 그래프
    - 이중 결합 컴포넌트(biconnected component) : 
    - 절단점을 포함하지 않는 서브그래프를 뜻하며, 이중 결합 컴포넌트 내에서는 임의의 한 정점을
      그래프에서 지우더라도 정점 간의 연결 관계가 유지됩니다.
  - 방향 그래프
    - 강결합 컴포넌트(strongly connected components, SCC) :
    - 방향 그래프 상에서 두 정점 u와 v에 대해 양 방향으로 가는 경로가 모두 있을 때 두 정점은 같은
      SCC에 속해 있다고 말합니다.
    - 아래 그림 (a)는 한 그래프의 각 SCC들을 짙은 색 배경으로 구분해 보여줍니다.

![img4](/img/2020-01-01-Jongman-ch28-7-4.png)

- SCC의 재미있는 점은 방향 그래프에서 각 SCC 사이를 연결하는 간선들을 모으면 SCC들을 정점으로 하는
  DAG를 만들 수 있다는 것입니다.
  - 그림 (a)에서도 다섯 개의 SCC들이 DAG를 구성하고 있는 것을 볼 수 있습니다.
  - 원 그래프의 정점들을 SCC별로 분리하고 각 SCC를 표현하는 정점들을 갖는 새로운 그래프를 만드는
    과정을 그래프의 압축(condensation)이라고 부릅니다.

- SCC는 사이클과도 밀접하게 연관되어 있습니다.
  - 한 사이클에 포함된 정점들은 항상 같은 SCC에 속해 있게 됩니다.
  - 반대로 한 SCC에 속한 두 정점 사이를 잇는 양방향 경로를 합치면 두 정점을 포함하는 사이클이
    됩니다.


## 강경합 컴포넌트 분리를 위한 타잔의 알고리즘

- 강결합 컴포넌트 분리를 위한 타잔(Tarjan)의 알고리즘은 한 번의 깊이 우선 탐색으로 각 정점을 SCC별로
  분리합니다.
- 우선 임의의 정점에서부터 깊이 우선 탐색을 수행해 DFS 스패닝 트리를 만듭시다.
  - 위 챕터의 그림 (b)는 (a)에 주어진 그래프의 가장 왼쪽 정점에서 깊이 우선 탐색을 해서 얻을 수 있는
    스패닝 트리의 결과를 보여줍니다.
  - 이 그림에서 주목할 부분은 이 스패닝 트리를 적절히 자르기만 해도 정점들을 SCC로 분리할 수 있다는
    것입니다.

- 제가 이해하기로는, 간선을 적절히 잘라내어야 SCC로 분리가 가능하다는 뜻 같습니다.
  - 따라서 아래에서는 어떤 적절한 간선을 잘라낼 것인지 판단하고 잘라내는 과정을 진행합니다.

- 타잔의 알고리즘은 깊이 우선 탐색을 수행하면서 각 정점을 SCC로 묶습니다.
  - 이를 위해 간선을 따라 재귀 호출이 반환될 때마다 이 간선을 자를지 여부를 결정합니다.
  - 만약 간선을 자르기로 하면, 하나의 SCC를 새로 만듭시다.
- 그러면 이제 각 간선을 자를지 여부를 정해 봅시다.
  - 트리 간선(u,v)를 자른다는 것은 v에서 u로 갈 수 있는 경로가 없다는 뜻입니다.
  - v에서 u로 가는 경로에는 항상 역방향 간선이 하나 이상 포함되어 있어야 하므로, 이 점을 응용하도록
    합시다.
    - 절단점 판단 알고리즘과 같이, v를 루트로 하는 서브트리를 탐색하면서 만나는 역방향 간선을 이용해
      닿을 수 있는 가장 높은 점을 찾습니다.
    - 이 정점이 u혹은 그보다 높이 있는 정점이라면 이 역방향 간선을 통해 v에서 u로 갈 수 있고, 따라서
      간선(u,v)를 잘라서는 안 됩니다.

- 추가로, 절단점 판단 알고리즘은 무향 그래프에 대해 동작했으므로 역방향 간선만 신경 쓰면 됐지만,
  방향 그래프를 다루는 SCC 분리 문제에서는 교차 간선을 신경 써야 합니다.
  - 실제로 v를 루트로 하는 서브트리에서 밖으로 나가는 역방향 간선이 하나도 없더라도, (u,v)를 자를 수
    없는 경우가 있습니다.

- 이제 트리 간선(u,v)를 끊을 수 없는 경우가 언제인지 알 수 있습니다.
  - v를 루트로 하는 서브트리에서, v보다 먼저 발견된 정점으로 가는 역방향 간선이 있다면 (u,v)를
    끊어서는 안 됩니다.
  - 그런 역방향 간선이 없다고 해도, v보다 먼저 발견되었으면서 아직 SCC로 묶여 있지 않은 정점으로
    가는 교차 간선이 있다면 (u,v)를 끊어선 안 됩니다.

## 강경합 컴포넌트 분리 알고리즘의 구현


```cpp
// 그래프의 인접 리스트 표현
vector<vector<int> > adj;
// 각 정점의 컴포넌트 번호. 컴포넌트 번호는 0부터 시작하며,
// 같은 강결합 컴포넌트에 속한 정점들의 컴포넌트 번호가 같다.
vector<int> sccId;
// 각 정점의 발견 순서
vector<int> discovered;
// 정점의 번호를 담는 스택
stack<int> st;
int sccCounter, vertexCounter;
// here를 루트로 하는 서브트리에서 역방향 간선이나 교차 간선을
// 통해 갈 수 있는 정점 중 최소 발견 순서를 반환한다.
// (이미 SCC로 묶은 정점으로 연결된 교차 간선은 무시한다. )
int scc(int here){
    int ret = discovered[here] = vertexCounter++;
    // 스택에 here를 넣는다. here의 후손들은 모두 스택에서 here 후에 들어간다.
    st.push(here);
    for(int i = 0; i < adj[here].size(); ++i){
        int there = adj[here][i];
        // (here, there)가 트리 간선
        if(discovered[there] == -1)
            ret = min(ret, scc(there));
        // there가 무시해야 하는 교차 간선이 아니라면
        else if(sccId[there] == -1)
            ret = min(ret, discovered[there]);
    }
    // here에서 부모로 올라가는 간선을 끊어야 할지 확인한다.
    if(ret == discovered[here]){
        // here를 루트로 하는 서브트리에 남아 있는 정점들을 전부 하나의 컴포넌트로 묶는다.
        while(true){
            int t = st.top();
            st.pop();
            sccId[t] = sccCounter;
            if(t == here) break;
        }
        ++sccCounter;
    }
    return ret;
}
// tarjan의 SCC 알고리즘
vector<int> tarjanSCC(){
    // 배열들을 전부 초기화
    sccId = discovered = vector<int>(adj.size(), -1);
    // 카운터 초기화
    sccCounter = vertexCounter = 0;
    // 모든 정점에 대해 scc() 호출
    for(int i = 0; i < adj.size(); i++)
        if(discovered[i] == -1)
            scc(i);
    return sccId;
}

```

## SCC 위상 정렬

- 위의 코드에서 새 SCC가 생겨나는 시점은 항상 scc()함수가 종료하기 직전입니다.
- 이와 같은 속성 때문에 각 SCC는 위상 정렬의 역순으로 번호가 매겨집니다.
- dfs()가 늦게 종료하는 정점부터 배열하면 그래프의 위상 정렬 결과를 얻을 수 있는 것과 마찬가지라고
  생각하면 됩니다.
