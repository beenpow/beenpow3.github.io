---
title : Ch.16.1 비트마스크

categories:
- jongman

tags:
- jongman
---

# 도입

- 현대의 모든 CPU는 이진수를 이용해 모든 자료를 표현합니다.
- 이와 같은 특성을 이용해 정수의 이진수 표현을 자료 구조로 쓰는 기법을 비트마스크(bitmask)라고
  부릅니다.

> 비트마스크의 장점
- 더 빠른 수행시간
    - 비트마스크 연산은 O(1)에 구현되는 것이 많기 때문에, 적절히 사용할 경우 다른 자료 구조를
      사용하는 것보다 훨씬 빨리 동작합니다.
- 더 간결한 코드
    - 다양한 집합 연산들을 반복문 없이 한 줄에 쓸 수 있기 때문에 비트마스크를 적절히 사용하면 굉장히
      짧은 코드를 작성할 수 있습니다.
- 더 작은 메모리 사용량
    - 비트마스크를 이용하는 코드들은 같은 데이터를 더 적은 메모리를 사용해 표현할 수 있습니다.
- 연관 배열을 배열로 대체
    - 불린 값 배영을 키로 갖는 연관 배열 객체 map<vector<bool>, int>를 사용하고 있다고 합시다.
    - 이때 비트마스크를 써서 같은 정보를 정수 변수로 나타내면 단순한 배열 int[]를 사용해 같은 정보를
      나타낼 수 있습니다

# 용어 정의

- 부호 없는 N비트 정수형 변수는 N자리의 이진수로 쓸 수 있습니다.
- 이때 각 비트가 표현하는 값은 2^0 부터 2^N-1 까지 입니다.
- 2^N-1 에 해당하는 비트를 최상위 비트, 2^0을 나타내는 비트를 최하위 비트라고 부릅니다.
- 어떤 정수를 이진수로 표현했을때 어떤 비트의 위치가 1이라면 해당 비트가 "켜져있다"라고 말하고,
  0이라면 "꺼져 있다"라고 말합니다.

# 비트 연산자

## AND 연산

- 입력받은 두 정수를 한 비트씩 비교하면서, 두 정수에 해당 비트가 모두 켜져 있을 때만 결과의 비트를
  켭니다.

## OR 연산과 XOR 연산

- AND와 같이 비트별로 동작하지만 OR연산은 두 비트 중 하나라도 켜져 있을 경우, XOR연산은 하나는 켜져
  있고 하나는 꺼져 있을 경우 결과의 비트를 켠다는 차이점이 있습니다.

## NOT 연산

- 정수 하나를 입력받아 켜져 있는 비트는 끄고, 꺼져 있는 비트는 켠 결과를 반환합니다.

## Shift 연산

- 정수 a의 비트들을 왼쪽 또는 오른쪽으로 원하는 만큼 움직입니다.

# 유의할 점들

## 연산자 우선순위

- c++이나 java에서 &, |, ^ 등의 비트 연산자의 우선순위는 == 혹은 != 등의 비교 연산자보다 낮습니다.

```cpp
int c = (6 & 4 == 4);
```

- 위의 식에서 4 == 4 가 먼저 계산되고, 이 결과인 1이 6과 AND되어 c는 0이 됩니다.

```cpp
int d = ((6 & 4) == 4);

## 오버플로

- 두번째로 많이 하는 실수는 64비트 정수를 비트마스크로 사용할 때 발생하는 오버플로입니다.

```cpp
bool isBitSet(unsigned long long a, int b){
    return (a & (1 << b) > 0;
}
```

- c++에서 1은 부호 있는 32 비트 상수로 취급되기 때문에, b가 32이상이면 식(1 << b)에서 오버플로가
  발생합니다.
- 이 문제를 해결하기 위해서는 1 뒤에 이 상수가 부호 없는 64비트 정수임을 알려주는 접미사 ull을 붙여
  주어야 합니다.

## 부호 있는 정수형의 사용

- 부호 있는 정수형에서 최상위 비트가 켜진 숫자는 음수를 표현합니다.
- 예를 들면 음수를 오른쪽으로 시프트할때 왼쪽 끝 비트들이 0이 아니라 1로 채워진다든지 하는 차이가
  있습니다.
- 따라서 변수의 모든 비트를 다 쓰고 싶을때는 부호 없는 정수형을 쓰는 것이 좋습니다.
