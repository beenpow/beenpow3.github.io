---
title : COFO::Round 603 ( div 2 )

categories:
    - sweaB
    - COFO
tag:
    - sweaB
    - COFO
---
# COFO::Round #603 ( div 2 )
- virtual : yes
- [Link : COFO::603 (div 2)](https://codeforces.com/contest/1263)
- 0 solved
  - Aì™€ Cë²ˆì€ editorialì„ ë´ë„ clearí•˜ê²Œ ì´í•´ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
  - ìˆ˜í•™ì  ì´í•´ê°€ ë¶€ì¡±í•œ íƒ“ì¸ ê²ƒ ê°™ìŠµë‹ˆë‹¤.

## Problem A : Sweet Problem

- level : 1200
- tag : math
- time : x

### Point
- r, g, bì˜ ì„¸ ê°€ì§€ ìƒ‰ì´ ìˆê³ 
- ê° ìƒ‰ê¹”ë³„ë¡œ ì´ ì‚¬íƒ•ìˆ˜ê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤.
- í•˜ë£¨ì— ìƒ‰ì´ ë‹¤ë¥¸ ì‚¬íƒ• í•˜ë‚˜ì”©ì„ ê³¨ë¼ ì´ 2ê°œë¥¼ ë¨¹ëŠ”ë‹¤ê³  í• ë•Œ,
- ìµœëŒ€ ëª‡ì¼ê¹Œì§€ ì‚¬íƒ•ì„ ë¨¹ì„ ìˆ˜ ìˆëŠ”ì§€ ì¶œë ¥í•©ë‹ˆë‹¤.

### Design(x)

- ë¨¼ì € editorialì„ ì²¨ë¶€í•©ë‹ˆë‹¤.
- ì™„ë²½íˆ ì´í•´ë˜ì§€ ì•ŠëŠ” ë¶€ë¶„ì´ ìˆê³ , ì´í•´ë˜ëŠ”ëŒ€ë¡œ ì—…ë°ì´íŠ¸ í•˜ê² ìŠµë‹ˆë‹¤.

```cpp
1263A - Sweet Problem
Sort the values of ğ‘Ÿ, ğ‘”, ğ‘ such that ğ‘Ÿâ‰¥ğ‘”â‰¥ğ‘. Now consider two cases.

If ğ‘Ÿâ‰¥ğ‘”+ğ‘, then Tanya can take ğ‘” candies from piles ğ‘Ÿ and ğ‘”, and then â€” ğ‘ candies from piles ğ‘Ÿ and ğ‘. After that there may be a bunch of candies left in the pile ğ‘Ÿ that Tanya won't be able to eat, so the answer is ğ‘”+ğ‘.

Otherwise, we need to achieve the equality of the piles ğ‘Ÿ, ğ‘”, ğ‘. First, we make equal ğ‘Ÿ and ğ‘” by eating ğ‘Ÿâˆ’ğ‘” from the piles ğ‘Ÿ and ğ‘ (this can always be done since ğ‘Ÿ<ğ‘”+ğ‘). Then we make equal the piles ğ‘”, ğ‘ by eating ğ‘”âˆ’ğ‘ from the piles ğ‘Ÿ and ğ‘”. After that, ğ‘Ÿ=ğ‘”=ğ‘, and we can get three different cases.

ğ‘Ÿ=ğ‘”=ğ‘=0 â€” nothing needs to be done, Tanya has already eaten all the sweets;
ğ‘Ÿ=ğ‘”=ğ‘=1 â€” you can take candy from any of two piles so in the end there will always be one candy left;
ğ‘Ÿ=ğ‘”=ğ‘â‰¥2 â€” we reduce all the piles by 2, taking, for example, a candy from piles ğ‘Ÿ and ğ‘”, ğ‘” and ğ‘, ğ‘Ÿ and ğ‘. With such actions, Tanya eventually reaches the two previous cases, since the sizes of the piles are reduced by 2.
Since with this strategy we always have 0 or 1 candy at the end, Tanya will be able to eat candies for âŒŠğ‘Ÿ+ğ‘”+ğ‘2âŒ‹ days.
```
- r < g+bì¸ ê²½ìš°ì— ëŒ€í•´ í•´ë‹¹ í’€ì´ì—ì„œ ì œê³µí•˜ëŠ”ëŒ€ë¡œ r, g, bì— ê°€/ê°ì„ í•´ë‚˜ê°€ë„ r, g, bê°€ ê°™ì•„ì§€ì§€
  ì•ŠìŠµë‹ˆë‹¤.
  - ê·¸ë˜ë„ rê³¼ gì‚¬ì´ì˜ ê°’ ì°¨ì´, gì™€ bì‚¬ì´ì˜ ê°’ì°¨ì´ê°€ ì¤‘ìš”í•˜ë‹¤ëŠ” ëŠë‚Œì€ ì•Œê² ìŠµë‹ˆë‹¤.
- r >= g+bì¸ ê²½ìš°ëŠ” ëª…ë°±í•˜ê²Œ g+bì¼ ë™ì•ˆ ê°€ëŠ¥í•œ ê²ƒì„ ì´í•´í–ˆìŠµë‹ˆë‹¤.

#### Big O(time)

#### Big O(memory)

### Code(x)

```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define fi first
#define se second
#define rep(i,a,b) for(int i=a;i<b;i++)
#define r_rep(i,a,b) for(int i=a;i>b;i--)
using namespace std;


void process(){
    int v[3]={0};
    rep(i, 0, 3) cin >> v[i];
    sort(v, v+3);
    if( v[2] >= v[0] + v[1]) cout << v[0] + v[1] << endl;
    else cout << (v[0] + v[1] + v[2]) / 2 << endl;
}
int main(){
    cin.tie(0);
    int tc; cin >> tc;
    while(tc--){
        process();
    }
    return 0;
}
```

## Problem B : PIN Codes

- level : 1400
- tag : greedy, implementation
- time : x
- ì¢‹ì€ êµ¬í˜„ë¬¸ì œì…ë‹ˆë‹¤.
- ë³µì¡ë„ ê³„ì‚° ë° ì„¤ê³„ë¥¼ ì œëŒ€ë¡œ í•˜ì§€ ì•Šê³  ë¬¸ì œë¥¼ í’€ë ¤ê³  í•´ì„œì¸ì§€, êµ³ì´ í•„ìš”ì—†ëŠ” setê³¼ mapë“±ì„
  ê³ ë ¤í•˜ì—¬ ìƒê°í•˜ì˜€ìŠµë‹ˆë‹¤.
  - í•˜ì§€ë§Œ ë¬¸ì œì—ì„œ í•˜ë‚˜ì˜ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë‹¹ ìµœëŒ€ 10ê°œì˜ në§Œ ì£¼ì–´ì§€ê³ , TLEë¥¼ ì¼ìœ¼í‚¬ ê°€ëŠ¥ì„±ì€
    ë§¤ìš°ì ì€ë°ë„ ë§ì…ë‹ˆë‹¤.

### Point

- nê°œì˜ PIN codeê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤.
- nê°œë¥¼ ì ì ˆíˆ ì¡°ì ˆí•˜ì—¬, ì¤‘ë³µì´ ì—†ëŠ” nê°œì˜ ìˆ˜ë¡œ ë³€í˜•í•©ë‹ˆë‹¤.
- ì´ë•Œ, ë³€í˜•ì´ í•„ìš”í•œ ìµœì†Œ ê°¯ìˆ˜ì˜ PIN CODEë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤.
- ì¤‘ìš”í•œ ê²ƒì€, ì¶œë ¥ì‹œì— ë¬¸ì œì—ì„œ ì œì‹œí•œ PIN CODEì˜ ìˆœì„œë¥¼ ìœ„ë°°í•˜ì§€ ì•ŠëŠ”ê²ƒì…ë‹ˆë‹¤.


### Design(x)
- ì •ë§ ì—¬ëŸ¬ê°€ì§€ ì‹œë„ë¥¼ í•˜ì˜€ìŠµë‹ˆë‹¤.
- nì´ ìµœëŒ€ 10ê°œì¸ë°ë„ ë¶ˆêµ¬í•˜ê³ , mapì„ ì‚¬ìš©í•˜ì—¬ í’€ì—ˆê³ , ì½”ë“œê°€ ë§¤ìš° ì§€ì €ë¶„í•´ì¡ŒìŠµë‹ˆë‹¤.
- ê°„ë‹¨íˆ ì„¤ëª…í•˜ìë©´, mapì— ëª¨ë“  ìˆ˜ë¥¼ ë„£ì–´ë‘¡ë‹ˆë‹¤.
  - ê·¸ë¦¬ê³ , ì¤‘ë³µë˜ëŠ” ìˆ˜ë¥¼ ë³€ê²½í• ë•Œë§ˆë‹¤ mapì— ê°™ì€ ê²ƒì´ ìˆëŠ”ì§€ O(logN)ë§Œì— findë¥¼ ì´ìš©í•´ì„œ
    í™•ì¸í•©ë‹ˆë‹¤.
  - ì¤‘ë³µë˜ëŠ” ìˆ˜ê°€ ìˆëŠ” ê²½ìš°, ì²«ë²ˆì§¸ ìë¦¬ìˆ˜ì˜ ìˆ«ìë¥¼ í•˜ë‚˜ì”© ëŒë ¤ë³´ë©° ê³„ì† ì¤‘ë³µì²´í¬ë¥¼ í•´ì¤ë‹ˆë‹¤.
  - ì´í›„, ë‘ë²ˆì§¸ ìë¦¬ìˆ˜ì˜ ìˆ«ìë„ ëŒë ¤ë³´ì§€ë§Œ, ì‚¬ì‹¤ìƒ nì´ 10ì´ë¯€ë¡œ ë‘ë²ˆì§¸ ìˆ«ìê¹Œì§€ ê°ˆ ì¼ì€ ì—†ê² ìŠµë‹ˆë‹¤.

- virtual ëŒ€íšŒ ì¤‘ ACë¥¼ ë°›ì§€ ëª»í–ˆë˜ ì´ìœ ëŠ” ì•„ë˜ ì‹¤ìˆ˜ë•Œë¬¸ì´ì—ˆìŠµë‹ˆë‹¤.
  - ì´ì¤‘ forë¬¸ì¸ë°, ë‘ forë¬¸ì— ëª¨ë‘ ië³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì˜€ìŠµë‹ˆë‹¤.

#### Big O(time)

#### Big O(memory)

### Code(x)

```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define fi first
#define se second
#define rep(i,a,b) for(int i=a;i<b;i++)
#define r_rep(i,a,b) for(int i=a;i>b;i--)
using namespace std;
int n;
bool seen[10000];
vector<pair<string, int> > input; // string, index
map<string, int> mp;
void change(string& s, map<string, int>& mpp){
    // [0]
    rep(i, 0, 10){
        s[0] += 1;
        if(s[0] > '9') s[0] -= 10;
        if(mpp.count(s) == 0){
            mpp[s]++;
            return;
        }
    }
    // [1]
    rep(i, 0, 10){
        s[1] += 1;
        if(s[1] > '9') s[1] -= 10;
        if(mpp.count(s) == 0){
            mpp[s]++;
            return;
        }
    }
}
bool cmp(const pair<string, int>& a, const pair<string, int>& b){
    return a.second < b.second;
}
void process(){
    cin >> n;
    input.clear();
    input = vector<pair<string,int> >(n, {"", 0});
    mp.clear();
    memset(seen, false, sizeof(seen));
    rep(i, 0, n){
        cin >> input[i].first;
        input[i].second = i;
        mp[input[i].first]++;
    }
    sort(input.begin(), input.end());

    int ret = 0;
    rep(i, 0, n){
        string ori = input[i].first;
        if(seen[stoi(ori)]) continue;;
        if(mp[ori] > 1){
            int cnt = (int)mp[ori];
            ret += cnt-1;
            string s = ori;
            // ì‹¤ìˆ˜.. ië¡œ ëŒë¦¼
            rep(j, 0, n)if(strcmp((input[j].first).c_str(), (ori).c_str()) == 0){
                if(seen[stoi(s)] == false){
                    seen[stoi(s)] = true;
                    continue;;
                }
                change(s, mp);
                seen[stoi(s)] = true;
                input[j].first = s; // ì‹¤ìˆ˜
            }
        }else{
            // Do nothing
        }
    }
    cout << ret << endl;
    sort(input.begin(), input.end(), cmp);
    rep(i, 0, n){
        cout << input[i].first << endl;
    }
}
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    int tc; cin >> tc;
    while(tc--){
        process();
    }
    return 0;
}
```

## Problem C : Everyone is a Winner

- level : 1400
- tag : binary search, math, meet-in-the-middle, number theory
- time : x

### Point

- í•´ë‹¹ ë¬¸ì œë„ editorialì´ ì™„ë²½íˆ ì´í•´ë˜ì§€ ì•Šì•„ì„œ, ê°™ì´ ì²¨ë¶€í•©ë‹ˆë‹¤.
- ìˆ˜í•™ì í’€ì´ì™€ ì•Œê³ ë¦¬ì¦˜ì  í’€ì´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
  - ìˆ˜í•™ì í’€ì´ì—ì„œëŠ” ì™œ nê¹Œì§€ ëª¨ë‘ ë‚˜ëˆ ë³´ëŠ” í–‰ìœ„ê°€ í•„ìš”í•˜ì§€ ì•ŠëŠ”ì§€ ì¦ëª…í•©ë‹ˆë‹¤.
  - ê²°ë¡ ì ìœ¼ë¡œ ë£¨íŠ¸ nê¹Œì§€ë§Œì˜ ê³„ì‚°ìœ¼ë¡œ ì›í•˜ëŠ” ê°’ì„ ë‹¤ ì–»ì„ ìˆ˜ ìˆë‹¤ëŠ” ì˜ë¯¸ì¸ë°, ì™„ë²½íˆ ì´í•´í•˜ì§€
    ëª»í•˜ì˜€ìŠµë‹ˆë‹¤.

```cpp
There are two approaches to solving this problem.

Mathematical Solution

Note that the answer will always contain the numbers 0â‰¤ğ‘¥<âŒŠğ‘›âˆšâŒ‹. You can verify this by solving the equation âŒŠğ‘›ğ‘˜âŒ‹=ğ‘¥, equivalent to the inequality ğ‘¥â‰¤ğ‘›ğ‘˜<ğ‘¥+1, for integer values â€‹â€‹of ğ‘˜. The solution to this double inequality is the interval ğ‘˜âˆˆ(ğ‘›ğ‘¥+1;ğ‘›ğ‘¥], whose length is ğ‘›ğ‘¥2+ğ‘¥. For ğ‘¥<âŒŠğ‘›âˆšâŒ‹ ğ‘›ğ‘¥2+ğ‘¥>1, and on an interval of length greater than 1 there is always a whole solution ğ‘˜=âŒŠğ‘›ğ‘¥âŒ‹, so all integers 0â‰¤ğ‘¥<âŒŠğ‘›âˆšâŒ‹ belong to the answer.

Note that we no longer need to iterate over the values â€‹â€‹of ğ‘˜>âŒŠğ‘›âˆšâŒ‹, because these numbers always correspond to the values â€‹â€‹0â‰¤ğ‘¥<âŒŠğ‘›âˆšâŒ‹. Thus, it is possible, as in a naive solution, to iterate over all the values â€‹â€‹of ğ‘˜ upto âŒŠğ‘›âˆšâŒ‹ and add ğ‘¥=âŒŠğ‘›ğ‘˜âŒ‹ to the answer. It remains only to carefully handle the case ğ‘˜=âŒŠğ‘›âˆšâŒ‹.

Total complexity of the solution: O(ğ‘›âˆšlogğ‘›) or O(ğ‘›âˆš)
Algorithmic Solution

In the problem, it could be assumed that there are not so many numbers in the answer (after all, they still need to be printed, which takes the majority of the program execution time). Obviously, ğ‘› always belongs to the answer. Note that as ğ‘˜ increases, the value of ğ‘¥=âŒŠğ‘›ğ‘˜âŒ‹ decreases. Thus, using a binary search, you can find the smallest value of ğ‘˜â€² such that ğ‘›ğ‘˜â€²<ğ‘¥. Value ğ‘¥â€²=ğ‘›ğ‘˜â€² will be the previous one for ğ‘¥ in the answer.

Total complexity of the solution: O(ğ‘›âˆšlogğ‘›)
```

- ì½”ë“œëŠ” nì˜ ì•½ìˆ˜ë¥¼ êµ¬í•˜ëŠ” ì½”ë“œì™€ ë§¤ìš° í¡ì‚¬í•©ë‹ˆë‹¤.
- ë‹¤ë§Œ, if(n%i == 0) ì´ ì—†ì–´ì¡ŒìŠµë‹ˆë‹¤.
- ì¦‰, ì•½ìˆ˜ëŠ” ì•„ë‹ˆì§€ë§Œ ë£¨íŠ¸ nê¹Œì§€ì˜ ië§Œì„ ì´ìš©í•´ì„œ, n/kë¥¼ ì •ìˆ˜ë¡œ ë§Œë“œëŠ” ëª¨ë“  ìˆ˜ë¥¼ êµ¬í•  ìˆ˜ ìˆë‹¤ëŠ”
  ì˜ë¯¸ì…ë‹ˆë‹¤.

### Design(x)

#### Big O(time)

#### Big O(memory)

### Code(x)

```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define fi first
#define se second
#define rep(i,a,b) for(int i=a;i<b;i++)
#define r_rep(i,a,b) for(int i=a;i>b;i--)
using namespace std;

int n;
void process(){
    cin >> n;
    vector<int> ans;
    ans.push_back(0);
    for(int i = 1; i * i <= n; i++){
        ans.push_back(i);
        if(n / i != i) ans.push_back(n / i);
    }
    sort(ans.begin(), ans.end());
    ans.erase(unique(ans.begin(), ans.end()), ans.end());
    cout << ans.size() << endl;
    rep(i, 0, ans.size()) cout << ans[i] << " ";
    cout << endl;
}
int main(){
    cin.tie(0);
    int tc; cin >> tc;
    while(tc--){
        process();
    }
    return 0;
}
```

## Problem D : Secret Passwords

- level : 1500
- tag : dfs and similar, dsu, graphs
- time : x
- í˜¹ì‹œ prnt[]ê°€ ëœ ì—…ë°ì´íŠ¸ ë˜ì–´ìˆì„ ìˆ˜ ìˆìœ¼ë‹ˆ í•­ìƒ, ì‚¬ìš©í• ë•, find(prn[])ë¡œ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.

### Point
- ì•ŒíŒŒë©§ ì†Œë¬¸ìë¡œë§Œ ì´ë£¨ì–´ì§„ ê¸¸ì´ ìµœëŒ€ 50ì¸ ë¬¸ìì—´ì´ ìµœëŒ€ 2 * 10^5ê°œ ì£¼ì–´ì§‘ë‹ˆë‹¤.
- ê° ë¬¸ìì—´ë“¤ ì¤‘ ê³µí†µë˜ëŠ” ë¬¸ìê°€ í•˜ë‚˜ë¼ë„ ìˆìœ¼ë©´ ê·¸ ë‘˜ì€ í•˜ë‚˜ë¡œ ìƒê°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- ì´ë•Œ, ë‹¤ë¥¸ ë¬¸ìì—´ ì¢…ë¥˜ì˜ ê°¯ìˆ˜ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤.

### Design(x)
- union-findë¡œ ì ‘ê·¼í•˜ì˜€ìŠµë‹ˆë‹¤.
- í•˜ì§€ë§Œ, ì½”ë“œë¥¼ ì§œë‹¤ë³´ë‹ˆ N^2ì¸ ê° ë¬¸ìì—´ë“¤ì— ëŒ€í•´ union-findë¡œëŠ” í•´ê²°í•  ìˆ˜ ì—†ì—ˆìŠµë‹ˆë‹¤.
- editorialì— ì œì‹œë˜ì–´ ìˆëŠ” ë°©ë²•ì€, ê° ë¬¸ìì—´ë“¤ì— ëŒ€í•œ union-findê°€ ì•„ë‹ˆë¼ 26ê°œ ì•ŒíŒŒë²³ì— ëŒ€í•œ
  union-findì…ë‹ˆë‹¤.
  - ì¦‰, í•œ ë¬¸ìì—´ ë‚´ì— í¬í•¨ëœ ë¬¸ìë“¤ì„ ê³„ì† mergeí•´ì£¼ëŠ”ê²ƒì…ë‹ˆë‹¤.
- ì´ë ‡ë“¯, ì‚¬ìš©ë˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì„ ì°¾ì•˜ë‹¤í•œë“¤ ì •í™•í•œ ê³³ì— ê°€ì ¸ë‹¤ ëŒ€ì§€ ì•Šìœ¼ë©´ ë‹µì„ ì°¾ì„ ìˆ˜ ì—†ëŠ” ê²ƒ
  ê°™ìŠµë‹ˆë‹¤.
- TLEê°€ í•´ê²°ë˜ì§€ ì•Šì„ë•, ì´ë ‡ê²Œ ì´ê³³ ì €ê³³ì— í•´ë‹¹ ì•Œê³ ë¦¬ì¦˜ì„ ëŒ€ì–´ë´ì•¼ê² ìŠµë‹ˆë‹¤.

#### Big O(time)

#### Big O(memory)

### Code(x)

```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define fi first
#define se second
#define rep(i,a,b) for(int i=a;i<b;i++)
#define r_rep(i,a,b) for(int i=a;i>b;i--)
using namespace std;
const int ALPHABET = 26;
const int MAXN = 2 * 100 * 1000 + 1;

int n;
int prnt[ALPHABET];
int exist[ALPHABET];

int find(int u){
    if(u == prnt[u]) return u;
    return prnt[u] = find(prnt[u]);
}

void merge(int u, int v){
    u = find(u); v = find(v);
    if(u == v) return;
    if(u > v) swap(u, v);
    prnt[v] = u;
}
void process(){
    // init
    rep(i, 0, ALPHABET) prnt[i] = i;

    cin >> n;
    rep(i, 0, n){
        string s; cin >> s;
        int abc[ALPHABET] = {0,};
        rep(j, 0, s.size()) abc[s[j]-'a'] = 1;

        int last = -1;
        rep(j, 0, ALPHABET) if(abc[j]){
            exist[j] = 1;
            if(last != -1) merge(j, last);
            last = j;
        }
    }
    set<int> st;
    rep(i, 0, ALPHABET) if(exist[i]){
        st.insert(find(prnt[i]));
    }
    cout << st.size() << endl;
}
int main(){
    freopen("input.txt", "r", stdin);
    ios_base::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    process();
    return 0;
}
```
