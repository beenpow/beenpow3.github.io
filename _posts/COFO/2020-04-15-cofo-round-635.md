---
title : COFO::Round 635 ( div 2 )

categories:
    - sweaB
    - COFO
tag:
    - sweaB
    - COFO
---
# COFO::Round #635 ( div 2 )
- [Link : COFO::635(div 2) ](https://codeforces.com/contest/1337)
- solved : 1
  - A :  ( 13m )
  - rank : 13453
  - score : 430
- B문제에 7트, C문제에 3트 하다가 끝난 대회였습니다.

## Problem A : Ichihime and Triangle

- level :
- tag : construcive algorithms, math
- time : 13m

### Point
- a <= x <= b, b <= y <= c, c <= z <= d 를 만족하는 a, b, c, d가 주어집니다.
- 삼각형을 이룰 수 있는 x, y, z를 출력합니다.

### Design(x)
- 삼각형의 성립 조건은 다음과 같습니다.
- x <= y <= z인 x, y, z가 주어질때, 
- z < x + y를 만족하면 해당 길이의 선분을 이용해 삼각형을 만들 수 있습니다.
- 따라서, 단순히 경계값만 출력하면 되는 문제입니다.

#### Big O(time)

#### Big O(memory)

### Code(x)

```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define fi first
#define se second
#define pb push_back
#define rep(i,a,b) for(int i=a;i<b;i++)
#define r_rep(i,a,b) for(int i=a;i>b;i--)
const int MAXN = 1000 * 1000 * 1000;
using namespace std;
typedef long long ll;

void process(){
    ll a, b, c, d, x, y, z;
    cin >> a >> b >> c >> d;
    x = b, y = c, z = c;
    cout << x << " "<< y << " "<< z << endl;
}
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    int tc; cin >> tc;
    while(tc--){
        process();
    }
    return 0;
}
```

## Problem B : Kana and Dragon Quest game

- level :
- tag : greedy, math
- time :
- 7트하며 1시간정도를 사용한 문제입니다.

### Point
- 용의 체력 x와 1번마법의 사용가능횟수인 n, 2번 마법의 사용가능횟수인 m이 주어집니다.
- n과 m을 사용하고 싶은 만큼 사용해서 용의 체력을 0이하로 만들 수 있다면, "YES" 그렇지 않다면 "NO"를 출력합니다.
- 1번 마법의 경우,
  - 용의 체력이 x일때, round(x/2) + 10으로 만들 수 있습니다.
- 2번 마법의 경우,
  - 용의 체력이 x일때, x-10으로 만들 수 있습니다.

### Design(x)
- BFS로 7트를 하였습니다.
  - status[100000][30][30]으로 사용하였습니다.
  - 최초엔, status[30][30]이었습니다만, n과 m의 순서에 따라 현재 남은 체력이 다를 수 있기때문입니다.
- 위의 방법으로는 TLE만 도출됩니다.
- 그 이유는, O(100000 * 30 * 30)에 대해서 모두 돌아야 하고 TC = 1000이기 때문입니다.
- 더 정확한 이유는 다음과 같습니다.
- 1번 마법을 사용해서 round(x/2) + 10을 하는 경우, x보다 다시 커지는 경우가 많습니다.
- ex) x = 18인 경우, round(18/2) + 10 = 19입니다.
- 따라서, 이분탐색하듯이, 1번마법을 통해 절반으로 계속 삭감시켜주고,
- 더이상 값이 변하지 않을때는 2번 마법을 통해 값을 가감해줘야 답을 시간내에 도출할 수 있는 그리디 문제입니다.

#### Big O(time)

#### Big O(memory)

### Code(x)

## Problem C : Linova and Kingdom

- level :
- tag :
- time :

### Point

### Design(x)

#### Big O(time)

#### Big O(memory)

### Code(x)

## Problem D : Xenia and Colourful Gems

- level :
- tag :
- time :

### Point

### Design(x)

#### Big O(time)

#### Big O(memory)

### Code(x)
