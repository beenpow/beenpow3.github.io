---
title : COFO::Round 703

categories:
    - COFO
    - 코드포스
tag:
    - COFO
    - 코드포스
---
# COFO::Round #703
- [Link : COFO::round 703](https://codeforces.com/contest/1486)
- solved : 
  - A :  ( 00:21 )
  - rank : 9926
  - score : 308

## Problem A

- level : 900
- tag : greedy, implementation
- time : 00:21

### Point

### Design

#### Big O(time)

#### Big O(memory)

### Code

```cpp
#define rep(i, a, b) for(int i=(a); i<(b); i++)
#define r_rep(i, a, b) for(int i=(a); i>(b); i--)
#include<bits/stdc++.h>
using namespace std;

int n;
typedef long long ll;
void solve(){
    cin >> n;
    bool ok = true;
    ll x, LEFT = 0, itr = 0;
    rep(i, 0, n){
        cin >> x;
        if(!ok) continue;
        
        LEFT += x;
        if(LEFT < itr) ok = false;
        else LEFT = LEFT - itr;
        itr = (i+1);
    }
    if(ok) cout << "YES\n";
    else cout << "NO\n";
}
int main(){
    //freopen("input.txt", "r", stdin);
    int tc; cin >> tc;
    while(tc--){
        solve();
    }
    return 0;
}

```

## Problem B

- level : 1500
- tag : binary search, geometry, shortest paths, sortings

### Point

### Design

#### Big O(time)

#### Big O(memory)

### Code

```cpp
#define rep(i, a, b) for(int i=(a); i< (b); i++)
#define r_rep(i, a, b) for(int i=(a): i>(b); i--)
#include<iostream>
#include<vector>
#include<algorithm>
typedef long long ll;
using namespace std;

int n;
vector<int> x, y;
ll findCount(vector<int>& a){
    if(a.size()%2) return 1;
    sort(a.begin(), a.end());
    return a[ a.size()/2] - a[ a.size() / 2 -1] + 1;
}
void solve(){
    cin >> n;
    x.clear(); x.resize(n);
    y.clear(); y.resize(n);
    rep(i, 0, n) cin >> x[i] >> y[i];
    
    ll ans = findCount(x) * findCount(y);
    cout << ans << '\n';
}
int main(){
    //freopen("input.txt", "r", stdin);
    int tc; cin >> tc;
    while(tc--)
        solve();
    return 0;
}

```

## Problem C1 ( easy version )

- level : 1600
- tag : binary search, interactive
- C1과 C2는 동일한 문제이며, 차이점은 사용할 수 있는 쿼리의 갯수입니다.

### Point
- 해당 문제의 쿼리 갯수 제한은 40개 입니다.
- n이 주어집니다.
- 문제 채점 시스템이 서버이고, 코드를 짜는 입장에서는 클라이언트로 설명하겠습니다.
- 서버는 n개의 서로 다른 수를 가지고 있습니다.
- 이때, 가능한 쿼리의 갯수 Q개 이내에 n개의 수 중 가장 큰 수를 찾아서 해당 인덱스를 출력하면 됩니다.
- 가능한 쿼리문은 한 가지이며, 다음과 같습니다.
  - query(l, r)
  - 범위 [l:r]에 대해서 2번째로 큰 수는 무엇이니?

### Design
- 40개를 보는 순간 적당한 풀이가 생각납니다.
- 물론 대회중엔 못 풀었지만, 좋은 문제라고 생각되어 끝나고 혼자 풀어보았고 여전히 좋은 문제라고 생각합니다.
- 40이내에 가능한 풀이는 binary search를 떠올릴 수 있습니다.
- n의 범위는 [2: 10^5]입니다.
- 풀이는 다음과 같습니다.
- 다음과 같은 함수의 재귀를 통해 40번 이내에 답을 찾을 수 있습니다.
  - 범위 [l:r]에 대해서 second max인 lr_seMx를 구합니다.
  - 그리고, 범위 [l:mid]와 [mid:r]에 대해서도 각각 second max인, l_seMx, r_seMx를 구합니다.
    - mid 는 l과 r의 중간값입니다.
    - 주의할 점은 (r-l+1)이 3인 경우엔 예외처리를 해주어야 한다는 점이고 코드를 참고하는게 좋겠습니다.
  - 이제 세 수, lr_seMx, l_seMx, r_seMx를 통해 이분 탐색의 방향을 결정할 수 있습니다.
  - lr_seMx 즉 구간 전체에 대한 2번째 max 값이 l_seMx 혹은 r_seMx와 같은 경우 ( case 1 )
    - 이렇게 같은 경우, 해당 구간에 1번째 max값도 포함된다는 의미이므로 해당 구간으로 좁혀서 재귀를 보냅니다.
  - 그 외의 경우 ( case 2 )
    - lr_seMx의 인덱스를 포함하지 않는 구간으로 재귀를 보냅니다.
    - 그 이유는 조금 생각해보면 알 수 있습니다. 
      - 구간 [l:mid] , [mid+1:r]에 대해서, 첫 번째  max와 두 번째 max가 각각 다른 구간에 속해있는 경우입니다.

#### Big O(time)
- 2 * log(10^5) < 40

### Code

```cpp
#define rep(i, a, b) for(int i=(a); i< (b); i++)
#define r_rep(i, a, b) for(int i=(a): i>(b); i--)
#define MID (len==3?mid:mid+1)
#include<iostream>
typedef long long ll;
using namespace std;

int n;
int getSecondMax(int l, int r){ int ret = -1; cout << "? " << l << " " << r << '\n'; cin >> ret; return ret; }
int whenLeftTwo(int l, int r){
    int ret = getSecondMax(l, r);
    if(ret == l) ret = r;
    else if(ret == r) ret = l;
    return ret;
}

// 그냥 구간 2개에 대해서 변수 따로 정하는게 깔끔해질 듯!
int bs(int l, int r, int lr_seMx){
    int len = r - l + 1,
        mid = (l + r) / 2;
    
    if(len == 2){
        int ret = whenLeftTwo(l, r);
        return ret;
    }
    
    int l_seMx = getSecondMax(l, mid),
        r_seMx = getSecondMax(MID, r);
    
    // case 1
    if(lr_seMx == l_seMx || lr_seMx == r_seMx){
        //  max in [l:mid]
        if(lr_seMx == l_seMx){
            return bs(l, mid, l_seMx);
        }
        // max in [mid+1:r]
        else{
            return bs(MID, r, r_seMx);
        }
    }
    // case 2
    else{
        // max in [mid+1:r]
        if(lr_seMx <= mid){
            return bs(MID, r, r_seMx);
        }
        // max in [l:mid]
        else{
            return bs(l, mid, l_seMx);
        }
    }
}

void solve(){
    cin >> n;
    if(n == 2){
        int ret = whenLeftTwo(1, n);
        cout << "! " << ret << '\n';
        return;
    }
    int ans = bs(1, n, getSecondMax(1, n));
    cout << "! " << ans << '\n';
}

int main(){
    //freopen("input.txt", "r", stdin);
    solve();
    return 0;
}


```

## Problem C2 ( hard version )

- level : 1900
- tag : binary search, interactive

### Point
- C1과 문제는 동일하며, 사용할 수 있는 쿼리의 최대 갯수가 20개입니다.

### Design
- 해당 문제는 혼자 풀이하지 못하여, editorial을 참고하였습니다.
- 방법은 생각보다 심플하지만 쿼리의 갯수를 C1대비 대략 절반으로 줄일 수 있었습니다.
- 최초에 범위 [1:n]에 대해서 second max인 smax를 구합니다.
- 이제 가장큰 max가 포함된 구간은 smax기준으로 좌 혹은 우 입니다.
  - 좌인지 우인지는 쿼리문 한번으로 확인 가능하지요.
- 이후, 정해진 구간에 대해서 간단한 이분탐색을 진행하면 됩니다.
  - 그 이분 탐색은 다음과 같습니다.
  - 구간 좌인 경우, max는 [1:smax] 구간 내에 있습니다.
  - 구간 우인 경우, max는 [smax:n] 구간 내에 있습니다.
  - 이를 활용하여, smax를 포함하여 쿼리문을 날렸을때 돌아오는 값이 smax인지 아닌지를 통해 max가 어디쯤 포함되는지 추정해 나갈 수 있습니다.

#### Big O(time)
- 2 + log(10^5)

### Code

```cpp
#define rep(i, a, b) for(int i=(a); i< (b); i++)
#define r_rep(i, a, b) for(int i=(a): i>(b); i--)
#include<iostream>
typedef long long ll;
using namespace std;

int n;
int getSecondMax(int l, int r){
    if(l >= r)return -1;
    int ret = -1;
    cout << "? " << l+1 << " " << r+1 << '\n';
    cin >> ret;
    return ret - 1;
}
void solve(){
    cin >> n;
    int smax = getSecondMax(0, n-1);
    if(smax == 0 || getSecondMax(0, smax) != smax){
        int l = smax, r = n - 1;
        while(r - l > 1){
            int m = (l + r) / 2;
            if(getSecondMax(smax, m) == smax)
                r = m;
            else
                l = m;
        }
        cout << "! " << r + 1 << '\n';
    }else{
        int l = 0, r = smax;
        while(r - l > 1){
            int m = (l + r) / 2;
            if(getSecondMax(m, smax) == smax)
                l = m;
            else
                r = m;
        }
        cout << "! " << l + 1 << '\n';
    }
}

int main(){
    //freopen("input.txt", "r", stdin);
    solve();
    return 0;
}
```
