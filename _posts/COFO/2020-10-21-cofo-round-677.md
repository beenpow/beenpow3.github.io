---
title : COFO::Round 677 ( div 3 )

categories:
    - COFO
    - 코드포스
tag:
    - COFO
    - 코드포스
---
# COFO::Round #677 ( div 3 )
- [Link : COFO::round 677 ( div 3 )](https://codeforces.com/contest/1433)
- solved : 
  - A :  ( 00:14 )
  - B :  ( 00:21 )
  - C :  ( 00:43 )
  - D :  ( 01:20 )
  - rank :  5710
  - score : 4 solved
  - reviewed : 6 problems

## Problem A : Boring Apartments

- level : 800
- tag : implementation, math
- time : 00:14

### Point

### Design

#### Big O(time)

#### Big O(memory)

### Code

```cpp
// https://beenpow.github.io/
#include<bits/stdc++.h>
#define endl '\n'
#define pb push_back
//#define f first
//#define s second
#define all(v) (v).begin(), (v).end()
#define rep(i,a,b) for(int i=a;i<b;i++)
#define r_rep(i,a,b) for(int i=a;i>b;i--)
#define vi vector<int>
#define vll vector<ll>
#define vpi vector<pair<int, int> >
#define vpll vector<pair<ll, ll> >
typedef long long ll;
using namespace std;
vi element = {1, 11, 111, 1111, 2, 22, 222, 2222, 3, 33, 333, 3333, 4, 44, 444, 4444,
    5, 55, 555, 5555, 6, 66, 666, 6666, 7, 77, 777, 7777, 8, 88, 888, 8888, 9, 99, 999, 9999
};
void process(){
    string s; cin >> s;
    int ans = (s[0] - '1') * 10;
    int len = s.size();
    if(len == 1) ans += 1;
    else if(len == 2) ans += 3;
    else if(len == 3) ans += 6;
    else if(len == 4) ans += 10;
    cout << ans << endl;
}
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    int tc; cin >> tc;
    while(tc--)
        process();
    return 0;
}
```


## Problem B : Yet Another Bookshelf

- level : 800
- tag : greedy, implementation
- time : 00:21

### Point

### Design

#### Big O(time)

#### Big O(memory)

### Code

```cpp
// https://beenpow.github.io/
#include<bits/stdc++.h>
#define endl '\n'
#define pb push_back
//#define f first
//#define s second
#define all(v) (v).begin(), (v).end()
#define rep(i,a,b) for(int i=a;i<b;i++)
#define r_rep(i,a,b) for(int i=a;i>b;i--)
#define vi vector<int>
#define vll vector<ll>
#define vpi vector<pair<int, int> >
#define vpll vector<pair<ll, ll> >
typedef long long ll;
using namespace std;
vi a;
void process(){
    int n; cin >> n;
    a.resize(n);
    rep(i, 0, n) cin >> a[i];
    int ans = 0;
    int cnt0 = 0;
    bool started = false;
    rep(i, 0, n){
        if(a[i]){
            if(!started) started = true;
            else{
                ans += cnt0;
                cnt0 = 0;
            }
        }else{
            if(started) cnt0++;
        }
    }
    cout << ans << endl;
}
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    int tc; cin >> tc;
    while(tc--)
        process();
    return 0;
}
```

## Problem C : Dominant Piranha

- level : 900
- tag : constructive algorithms, greedy
- time : 00:43

### Point

### Design

#### Big O(time)

#### Big O(memory)

### Code

```cpp
// https://beenpow.github.io/
#include<bits/stdc++.h>
#define endl '\n'
#define pb push_back
//#define f first
//#define s second
#define all(v) (v).begin(), (v).end()
#define rep(i,a,b) for(int i=a;i<b;i++)
#define r_rep(i,a,b) for(int i=a;i>b;i--)
#define vi vector<int>
#define vll vector<ll>
#define vpi vector<pair<int, int> >
#define vpll vector<pair<ll, ll> >
typedef long long ll;
using namespace std;

int n;
vi a;
vi LE, RI;
void process(){
    cin >> n;
    a.clear(); LE.clear(); RI.clear();
    a.resize(n); LE.resize(n); RI.resize(n);
    int mx = -1;
    rep(i, 0, n){
        cin >> a[i];
        if(a[i] > mx) mx = a[i];
    }
    int cnt = 0, id = -1;
    rep(i, 0, n) if(a[i] == mx) cnt++, id = i;
    if(cnt == 1){
        cout << id+1 << endl;
        return;
    }
    if(cnt == n){
        cout << "-1" << endl;
        return;
    }
    
    cnt = 0;
    rep(i, 0, n){
        if(a[i] == mx){
            LE[i] = cnt;
            cnt = 0;
        }else{
            cnt++;
        }
    }
    
    r_rep(i, n-1, -1){
        if(a[i] == mx){
            RI[i] = cnt;
            cnt = 0;
        }else{
            cnt++;
        }
    }
    
    int nmx = -1;
    rep(i, 0, n){
        if(a[i] == mx){
            LE[i] += RI[i];
        }
        if(nmx < LE[i]){
            nmx = LE[i];
        }
    }
    rep(i, 0, n){
        if(LE[i] == nmx){
            cout << i+1 << endl;
            return;
        }
    }
    
}
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    int tc; cin >> tc;
    while(tc--)
        process();
    return 0;
}
```

## Problem D : Districts Connection

- level : 1200
- tag : constructive algorithms, dfs and similar, dsu, trees
- time : 01:20

### Point

### Design

#### Big O(time)

#### Big O(memory)

### Code

```cpp
// https://beenpow.github.io/
#include<bits/stdc++.h>
#define endl '\n'
#define pb push_back
#define f first
#define s second
#define all(v) (v).begin(), (v).end()
#define rep(i,a,b) for(int i=a;i<b;i++)
#define r_rep(i,a,b) for(int i=a;i>b;i--)
#define vi vector<int>
#define vll vector<ll>
#define vpi vector<pair<int, int> >
#define vpll vector<pair<ll, ll> >
typedef long long ll;
using namespace std;

int n;
vi a;
map<int,int> mp, rmp;
void process(){
    cin >> n;
    a.resize(n);
    mp.clear(); rmp.clear();
    rep(i, 0, n){
        cin >> a[i];
        mp[ a[i] ]++;
    }
    if((int)mp.size() == 1 ){
        cout << "NO" << endl;
        return;
    }else cout << "YES" << endl;
    
    for(auto x : mp){
        rmp[ x.s ] = x.f; // 덮어 씌워져도 상관없음
    }
    
    int root_idx = -1;
    int root_gang_id = rmp.begin()->s, root_cnt = rmp.begin()->f;
    int ecpt = -1;
    rep(i, 0, n) if(a[i] == root_gang_id){ root_idx = i+1; break; }
    rep(i, 0, n){
        if(a[i] != root_gang_id){
            cout << root_idx << " " << i+1 << endl;
            ecpt = i+1;
        }
    }
    bool flag = false;
    rep(i, 0, n){
        if(a[i] == root_gang_id){
            if(flag)
                cout << i+1 << " " << ecpt << endl;
            else flag = true;
        }
    }
}
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    int tc; cin >> tc;
    while(tc--)
        process();
    return 0;
}
```

## Problem E : Two Round Dances

- level : 1300
- tag : combinatorics, math

### Point

### Design

#### Big O(time)

#### Big O(memory)

### Code

```cpp
// https://beenpow.github.io/
#include<bits/stdc++.h>
#define endl '\n'
#define pb push_back
#define f first
#define s second
#define all(v) (v).begin(), (v).end()
#define rep(i,a,b) for(int i=a;i<b;i++)
#define r_rep(i,a,b) for(int i=a;i>b;i--)
#define vi vector<int>
#define vll vector<ll>
#define vpi vector<pair<int, int> >
#define vpll vector<pair<ll, ll> >
typedef long long ll;
using namespace std;

ll n;
void process(){
    cin >> n;
    ll ans = 1;
    for(ll i = n/2 + 1; i <= n; i++) ans *= i;
    for(ll i = 1; i <= n/2; i++) ans /= i;
    
    ll mul = 1;
    for(ll i = 1; i < n/2; i++) mul *= i;
    cout << ans * mul * mul / 2 << endl;
}
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
        process();
    return 0;
}
```

## Problem F : Zero Remainder Sum

- level : 2100
- tag : dp

### Point

### Design

#### Big O(time)

#### Big O(memory)

### Code

```cpp
// https://beenpow.github.io/
#include<bits/stdc++.h>
#define endl '\n'
#define pb push_back
#define f first
#define s second
#define all(v) (v).begin(), (v).end()
#define rep(i,a,b) for(int i=a;i<b;i++)
#define r_rep(i,a,b) for(int i=a;i>b;i--)
#define vi vector<int>
#define vll vector<ll>
#define vpi vector<pair<int, int> >
#define vpll vector<pair<ll, ll> >
typedef long long ll;
const int MAXN = 70, inf = 1e9;
using namespace std;

/* knapsack problem */
int n, m, k;
int a[MAXN][MAXN];
int dp[MAXN][MAXN][MAXN][MAXN];
// dp[x][y][cnt][rem] : 현재 a[x][y]에 있고, x 행에서 cnt개의 원소를 선택했고, 그 나머지가 rem이다.

void input(){
    cin >> n >> m >> k;
    rep(i, 0, n) rep(j, 0, m) cin >> a[i][j];
    
    rep(i, 0, MAXN) rep(j, 0, MAXN) rep(cnt, 0, MAXN) rep(rem, 0, MAXN) dp[i][j][cnt][rem] = -inf;
    dp[0][0][0][0] = 0;
}
void process(){
    input();
    rep(i, 0, n){
        rep(j, 0, m){
            rep(cnt, 0, m/2 + 1){
                rep(rem, 0, k){
                    if(dp[i][j][cnt][rem] == -inf) continue;
                    int ni = (j == m - 1 ? i + 1 : i );
                    int nj = (j == m - 1 ? 0 : j + 1 );
                    
                    // 현재 위치[i][j]의 값을 더하지 않는 경우
                    if(i != ni){ // 행이 바뀌는 경우
                        dp[ni][nj][0][rem] = max(dp[ni][nj][0][rem], dp[i][j][cnt][rem]);
                    }else{
                        dp[ni][nj][cnt][rem] = max(dp[ni][nj][cnt][rem], dp[i][j][cnt][rem]);
                    }
                    
                    // 현재 위치[i][j]의 값을 더하는 경우
                    if(cnt +1 <= m / 2){
                        int nrem = (rem + a[i][j]) % k;
                        
                        if(i != ni){ // 행이 바뀌는 경우
                            dp[ni][nj][0][nrem] = max(dp[ni][nj][0][nrem], dp[i][j][cnt][rem] + a[i][j]);
                        }else{
                            dp[ni][nj][cnt + 1][nrem] = max(dp[ni][nj][cnt + 1][nrem], dp[i][j][cnt][rem] + a[i][j]);
                        }
                    }
                }
            }
        }
    }
    cout << max(0, dp[n][0][0][0]) << endl;
}
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    process();
    return 0;
}
```
