---
title : COFO::Round 661 ( div 3 )

categories:
    - sweaB
    - COFO
tag:
    - sweaB
    - COFO
---
# COFO::Round #661 ( div 3 )
- [Link : COFO::round 661 ( div 3 )](https://codeforces.com/contest/1399)
- solved : 4
  - A : 00:06
  - B : 00:18
  - C : 00:35
  - D : 02:08
  - rank : 3411

## Problem A : Remove Smallest

- level : 800
- tag : greedy, sortings
- time : 00:06

### Point
- n이 주어집니다.
- n개의 원소로 이루어진 배열 a가 주어집니다.
- 작업이 나옵니다.
  - 서로 다른 인덱스 i, j를 선택합니다.
  - ai와 aj의 차가 1이하인 경우, 둘 중 작은 원소를 배열에서 삭제할 수 있습니다.
  - 만약 둘의 값이 같은 경우 아무 값을 삭제할 수 있습니다.
- 해당 작업을 충분히 사용하여, 원소의 갯수를 1개로 만들 수 있다면 "YES"를 출력
  - 그렇지 못한다면 "NO"를 출력합니다.

### Design(x)
- 일단, 연속된 i, j를 구하는 것이 아니므로 sorting을 해줍니다.
- 그리고 인접한 두 값의 차가 1보다 큰 것이 있다면 "NO"를 출력하고,
- 그러한 경우가 없는 경우 "YES"를 출력합니다.

#### Big O(time)
- O(NlogN)

#### Big O(memory)

### Code(x)

```cpp
#include<bits/stdc++.h>
#define all(v) (v).begin(), (v).end()
#define rep(i,a,b) for(int i=a;i<b;i++)
#define r_rep(i,a,b) for(int i=a;i>b;i--)
using namespace std;

int n;
vector<int> a;
void process(){
    cin >> n;
    a.clear(); a.resize(n);
    rep(i, 0, n) cin >> a[i];
    sort(all(a));
    for(int i=0; i < n-1; i++){
        int gap = abs(a[i] - a[i+1]);
        if(gap > 1){
            cout << "NO" << endl;
            return;
        }
    }
    cout << "YES" << endl;
    return;
}
int main(){
    int tc; cin >> tc;
    while(tc--){
        process();
    }
    return 0;
}
```

## Problem B : Gifts Fixing

- level : 800
- tag : greedy
- time : 00:18

### Point
- n이 주어집니다.
- 길이 n인 배열 a와 배열 b가 주어집니다.
- 배열 a의 i번째 원소 ai는 i번째 아이에게 줄 candy의 갯수를 의미합니다.
- 배열 b의 i번째 원소 bi는 i번째 아이에게 줄 orange의 갯수를 의미합니다.
- 최소한의 작업을 통해, 모든 아이가 공평하게 같은 수의 캔디와 오렌지를 받게하고 싶습니다.
  - 여기서의 작업은 3가지 종류가 있습니다.
  - ai = ai-1
  - bi = bi-1
  - ai = ai-1, bi = bi-1
- 이때의 작업의 수를 출력합니다.

### Design(x)
- 배열 a의 원소 중 가장 작은 값을 amin이라고 하고,
- 배열 b의 원소 중 가장 작은 값을 bmin이라고 합시다.
- 모든 원소가 같은 값을 같게 하기 위해서는 모두 amin과 bmin갯수를 보유해야합니다.
- 위와 같은 방법으로 진행하면 답을 도출할 수 있고,
- 고려해야할 Edge case는 모두 0개를 받게되는 경우가 존재할 수 있는가?를 체크하는 것이고,
- 가능합니다.

#### Big O(time)
- O(N)

#### Big O(memory)

### Code(x)

```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define all(v) (v).begin(), (v).end()
#define rep(i,a,b) for(int i=a;i<b;i++)
#define r_rep(i,a,b) for(int i=a;i>b;i--)
const int inf = 1000000000 + 10;
typedef long long ll;
using namespace std;

int n;
vector<int> a, b;
void process(){
    cin >> n;
    a.clear(); a.resize(n);
    b.clear(); b.resize(n);
    int amin = inf, bmin = inf;
    ll ans = 0;
    rep(i, 0, n){
        cin >> a[i];
        amin = min(amin, a[i]);
    }
    rep(i, 0, n){
        cin >> b[i];
        bmin = min(bmin, b[i]);
    }
    rep(i, 0, n){
        int opa = a[i] - amin, opb = b[i] - bmin;
        int gap = min(opa, opb);
        ans += gap;
        ans += opa - gap;
        ans += opb - gap;
    }
    cout << ans << endl;
}
int main(){
    int tc; cin >> tc;
    while(tc--){
        process();
    }
    return 0;
}
```

## Problem C : Boats Competition

- level : 1200
- tag : brute force, greedy, two pointers
- time : 00:35

### Point
- n이 주어집니다.
- 원소의 갯수가 n인 배열 a가 주어집니다.
- n개의 원소 중 i번째와 j번째 원소의 합을 s라 합시다. ( i != j )
- 배열 a에서 2개씩 원소를 뽑아서 합이 s인 갯수를 카운트할때, 최대 카운트가 되게 하는 s를 찾고
- 이때의 카운트 수를 출력합니다.

### Design(x)
- 어떻게 풀어야할지 고민을 좀 하였습니다.
- 명확한 로직이 떠오르지 않았지만 문제를 읽을때 n이 매우 작아서 이상하다는 생각은 하였습니다.
- 따라서, 이분탐색 혹은 브루트포스라는 방법을 생각해냈고,
- 모든 가능한 s값을 미리 구해놓고, 이 값을 갖는 짝을 찾는 브루트 포스 방법으로 풀이하였습니다. 

#### Big O(time)
- O(N^2)

#### Big O(memory)

### Code(x)

```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define pb push_back
#define all(v) (v).begin(), (v).end()
#define rep(i,a,b) for(int i=a;i<b;i++)
#define r_rep(i,a,b) for(int i=a;i>b;i--)
const int inf = 1000000000 + 10;
typedef long long ll;
using namespace std;

int n;
vector<int> a, s;
vector<bool> seen;
void process(){
    cin >> n;
    a.clear(); a.resize(n);
    seen.clear(); seen.resize(n);
    rep(i, 0, n) cin >> a[i];
    rep(i, 0, n) rep(j, i+1, n){
        int sum = a[i] + a[j];
        s.pb(sum);
    }
    sort(all(s));
    s.erase(unique(all(s)), s.end());
    int ans = 0;
    rep(i, 0, s.size()){
        // init
        int si = s[i], cnt = 0;
        rep(j, 0, n) seen[j] = false;
        
        rep(j, 0, n){
            rep(k, 0, n) if(j != k && !seen[j] && !seen[k] && a[j] + a[k] == si){
                seen[j] = seen[k] = true;
                cnt++;
            }
        }
        
        ans = max(ans, cnt);
    }
    cout << ans << endl;
}
int main(){
    int tc; cin >> tc;
    while(tc--){
        process();
    }
    return 0;
}
```

## Problem D : Binary String To Subsequences

- level : 1500
- tag : constructive algorithms, data structures, greedy, implementation
- time : 02:08

### Point
- n이 주어집니다.
- 길이 n인 binary string s가 주어집니다.
- s의 subsequence를 sc라고 해봅시다.
- s를 최소한의 갯수의 sc로 분할하여 조건을 만족시키고자 합니다.
- 이때의 sc의 갯수와 s[i]가 속한 sc의 넘버링을 출력합니다.
- 만족해야 하는 조건은 다음과 같습니다.
- sc의 원소는 연속된 인덱스의 값이 같으면 안 됩니다.
  - 즉, 010101...0101 혹은 101010...1010 과 같은 꼴로 구성되어야 합니다.

### Design(x)
- 경과시간을 보시면 아시겠지만, 1시간 30분정도 고민하였습니다.
- 그만할까도 생각했지만 항상 이런 류의 문제를 풀지 못하는 것 같았기에 조금 더 매달려 보았습니다.
- 생각보다 간단한 풀이가 존재하였습니다.
- 확실히 substring보다 subsequnce의 난이도가 더욱 어렵게 느껴집니다.
- queue를 사용하는 방법으로 풀이하였습니다.
- 즉, sc의 종류를 2가지로 정해놓고 필요시 해당 sc에 원소들을 붙이는 작업을 진행합니다.
  - 하나는 0으로 끝나는 sc이고, 하나는 1로 끝나는 sc입니다.
- 예를 들어 보겠습니다.
  - 0011이 주어집니다.
  - 0번째 원소의 경우,
    - endZero에 원소를 push해줍니다.
  - 1번째 원소의 경우,
    - endZero에 원소를 push해줍니다.
  - 2번째 원소의 경우,
    - endOne에 원소를 push해야겠지만, 우리는 endZero에 0으로 끝나는 sc들을 보유중입니다.
    - 따라서 굳이 또 새로운 sc를 추가하는 것이 아니라,
    - 기존에 있던 0에 1을 붙여서 01을 만든 후, endOne에 push해줍니다.
  - 3번째 원소의 경우도 2번째 원소와 마찬가지입니다.

#### Big O(time)
- O(N)

#### Big O(memory)

### Code(x)

```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define pb push_back
#define all(v) (v).begin(), (v).end()
#define rep(i,a,b) for(int i=a;i<b;i++)
#define r_rep(i,a,b) for(int i=a;i>b;i--)
const int MAXN = 100000 * 2 + 10;
typedef long long ll;
using namespace std;

int n;
string s;
queue<int> endZero, endOne;
int grp[MAXN];
void process(){
    // init
    cin >> n >> s;
    rep(i, 0, n) grp[i] = 0;
    while(!endZero.empty()) endZero.pop();
    while(!endOne.empty()) endOne.pop();
    
    int cnt = 0;
    rep(i, 0, n){
        if(s[i] == '0'){
            if(!endOne.empty()){
                int grpIdx = endOne.front(); endOne.pop();
                grp[i] = grpIdx;
                endZero.push(grpIdx);
            }else{
                grp[i] = ++cnt;
                endZero.push(cnt);
            }
        }else{
            if(!endZero.empty()){
                int grpIdx = endZero.front(); endZero.pop();
                grp[i] = grpIdx;
                endOne.push(grpIdx);
            }else{
                grp[i] = ++cnt;
                endOne.push(cnt);
            }
        }
    }
    cout << cnt << endl;
    rep(i, 0, n){
        cout << grp[i] << " ";
    }
    cout << endl;
    
}
int main(){
    int tc; cin >> tc;
    while(tc--){
        process();
    }
    return 0;
}
```
