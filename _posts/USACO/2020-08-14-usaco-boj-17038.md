---
title : USACO SILVER::2019 February - The Great Revegetation (silver)

categories:
    - USACO

tag:
    - USACO
---
# USACO SILVER::2019 February - The Great Revegetation (silver)
- [Link : USACO BOJ::17038](https://www.acmicpc.net/problem/17038)
- [Link : USACO contest::2019 February](http://www.usaco.org/index.php?page=dec19results)
- 유사코 실버

# The Great Revegetation ( silver )

- level : Gold 3
- tag : 2-sat, disjoint-set, components
- union-find로 풀릴 것 같아서 집착하다보니, 구분해줘야할 경우의 수가 너무 많아졌습니다.
  - 따라서 푸는데 실패했고, components 갯수를 카운트 하는 문제라는 것을 알게되었습니다.
- 풀이를 보면, x와 3-x 로 컬러를 구분하며 해당 방법을 이러한 분리 집합 문제에 자주 사용하는 것 같으니 숙지해 두어야겠습니다.

# Point
- n과 m이 주어집니다.
- m마리 소가 각각 좋아하는 2곳의 pastures가 주어집니다.
- 소들은 자신이 좋아하는 두 곳에 같은 종류의 여물을 좋아하는지, 다른 종류의 여물을 좋아하는지 구분됩니다.
- 이때, 모든 pastures에 씨앗을 심는 경우의 수를 이진수로 출력합니다.

# Design(x)
- union-find로 시도하였지만 실패하였습니다.
  - merge함수에서 색을 구분해주는 case분류가 독립되지 않아서 실패하였습니다.
- solution을 보니 group counting을 통해 풀리는 문제였습니다.
- 방법은 다음과 같습니다.
  - 아직 방문되지 않은 노드를 방문하며, dfs로 adjacent한 노드들을 모두 방문해줍니다.
  - 중요한 점은, 최초 방문 노드의 색을 1로 설정하고,
  - 그와 이웃한 노드들이 같은 색인지 다른 색인지에 따라 색을 지정하며,
  - 이미 색이 있는 경우, 정당한지를 판단할 수 있다는 점을 이해하는 것입니다.
  - 이를 위해, adj 벡터를 same과 different 각각 구성해주어야 합니다.
- 즉, 문제에도 언급이 없기 때문에, 가짓수가 0인경우(불가능한 경우)가 있을 수 있기 때문에 위와 같이 정당성 판단도 해주어야 합니다.

# Big O(time)
- O(M)

# Big O(memory)

# Code(x)

```cpp
// https://beenpow.github.io/
#include<bits/stdc++.h>
#define endl '\n'
#define pb push_back
//#define f first
//#define s second
#define all(v) (v).begin(), (v).end()
#define rep(i,a,b) for(int i=a;i<b;i++)
#define r_rep(i,a,b) for(int i=a;i>b;i--)
#define vi vector<int>
#define vpi vector<pair<int, int> >
typedef long long ll;
const int MAXNM = 100000 + 10;
using namespace std;

bool impossible;
int n, m;
int colur[MAXNM];
vi s[MAXNM], d[MAXNM]; // same, different
void input(){
    cin >> n >> m;
    rep(i, 0, m){
        char ch; int u, v;
        cin >> ch >> u >> v;
        if(ch == 'S'){
            s[u].pb(v); s[v].pb(u);
        }else{
            d[u].pb(v); d[v].pb(u);
        }
    }
}
void dfs(int u, int what){
    colur[u] = what;
    rep(i, 0, s[u].size()){
        int v = s[u][i];
        if(colur[v] == 3 - what) impossible = true;
        if(colur[v] == 0) dfs(v, what);
        
    }
    rep(i, 0, d[u].size()){
        int v = d[u][i];
        if(colur[v] == what) impossible = true;
        if(colur[v] == 0) dfs(v, 3 - what);
    }
}
void process(){
    input();
    
    int grpCnt = 0;
    rep(i, 1, n+1){
        if(colur[i] == 0){
            dfs(i, 1);
            grpCnt++;
        }
    }
    
    if(impossible) cout << "0" << endl;
    else{
        cout << "1";
        rep(i, 0, grpCnt) cout << "0";
        cout << endl;
    }
}
int main(){
    freopen("input.txt", "r", stdin);
    process();
    return 0;
}
```
