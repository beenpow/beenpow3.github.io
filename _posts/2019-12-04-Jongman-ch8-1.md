---
title : Ch.8.1 동적계획법 [도입]

categories:
- jongman

tags:
- jongman
---

# 8.1 동적계획법 [도입]

## 중복되는 부분 문제
- 동적계획법과 분할 정복의 차이가 발생하는 부분은 문제를 나누는 방식입니다.
- 동적 계획법에서 어떤 부분 문제는 두 개 이상의 문제를 푸는 데 사용될 수 있기 때문에, 이 문제의 답을
  여러 번 계산하는 대신 한 번만 계산하고 계산 결과를 재활용함으로써 속도의 향상을 꾀할 수 있습니다.
- 그러기 위해서는 각 문제의 답을 메모리에 저장해 둘 필요가 있습니다.
- 이 때 이미 계산한 값을 저장해 두는 메모리의 장소를(cache)라고 부르며, 두 번 이상 계산되는 부분
  문제를 중복되는 부분 문제(overlapping subporblems)라고 부릅니다.
- 함수의 결과를 저장하는 장소를 마련해 두고, 한 번 계산한 값을 저장해 뒀다 재활용하는 최적화 기법을
  메모이제이션(memoization)이라고 부릅니다.

## 메모이제이션을 적용할 수 있는 경우
- 함수의 반환 값이 그 입력 값만으로 결정되는지의 여부를 유식한 말로 '참조적 투명성(referential
  transparancy)'이라고 부릅니다.
- 입력이 고정되어 있을 때 그 결과가 항상 같은 함수들을 '참조적 투명함수(referential transparent
  function)'이라고 부릅니다.
- 당연하게도 메모이제이션은 참조적 투명 함수의 경우에만 적용할 수 있습니다. 입력이 같은데도 외부
  요소에 따라 다른 값이 반환되면 캐싱을 할 수가 없습니다.

## 메모이제이션 구현 패턴
- 메모이제이션은 사용빈도가 높은 만큼, 한 가지 패턴을 정해두고 항상 같은 형태로 구현하기로 하면
  작성하기도, 버그를 찾기도 쉬워집니다.

### 항상 기저 사례를 제일 먼저 처리합니다.
- 입력이 범위를 벗어난 경우 등을 기저 사례로 처리하면 매우 유용한데, 기저 사례를 먼저 확인하지 않고
  cache[]에 접근하면 범위를 벗어나는 등의 오류가 있을 수 있습니다.

### 함수의 반환 값이 항상 0 이상이라는 점을 이용해 cache[]를 모두 -1로 초기화합니다.
- cache[]의 해당 위치에 적혀 있는 값이 -1이라면 이 값은 계산된 반환 값일리 없습니다.
- 만약 함수의 반환 값이 음수일 수도 있다면 이 방법은 써먹을 수 없을 것입니다.

### ret가 cache[a][b]에 대한 참조형(reference)이라는 데에 유의합니다. 
- 참조형 ret의 값을 바꾸면 cache[a][b]의 값도 변하기 때문에 답을 저장할 때도 매번 귀찮게
  cache[a][b]라고 쓸 필요가 없어집니다.
- 이 트릭은 특히 cache가 다차원 배열일 때 유용합니다.
- 귀찮기는 둘째 치고 인덱스 순서를 바꿔 쓴다거나 하는 실수를 할 가능성을 없애줍니다.

### memset()을 이용해 cache[]를 초기화하는 부분입니다.
- 메모이제이션용 배열을 초기화하는 것은 매우 자주 하는 일이기 때문에 다중 for문보다 쉽게 초기화 할
  수 있는 방법을 알아두면 간편합니다. 
- 단, memset()으로 배열을 초기화하는 방법은 괸장히 제한적인 경우만 쓸 수 있습니다.

ex)

{% highlight ruby %}

// 전부 -1로 초기화해 둔다
int cache[2500][2500];
// a와 b는 각각 [0, 2500) 구간 안의 정수
// 반환 값은 항상 int형 안에 들어가는 음이 아닌 정수
int someObscureFunction(int a, int b){
    // 기저 사례를 처음에 처리한다
    if(...) return ...;
    // (a,b)에 대한 답을 구한 적이 있으면 곧장 반환 
    int& ret = cache[a][b];
    if(ret != -1) return ret;
    // 여기에서 답을 계산한다.
    ...
    return ret;
}
int main(){
    //  memset()을 이용해 cache배열을 초기화한다.
    memset(cache, -1, sizeof(cache));
}

{% endhighlight %}

## 메모이제이션의 시간 복잡도 분석 
- 간단한 방법으로 아래와 같이 계산할 수 있습니다
- (존재하는 부분 문제의 수 ) * (한 부분 문제를 풀 때 필요한 반복문의 수행 횟수)
