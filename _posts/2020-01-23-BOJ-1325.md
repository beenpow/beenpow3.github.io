---
title : BOJ::1325 효율적인 해킹

categories:
    - sweaB
    - BOJ
tag:
    - sweaB
    - BOJ
---
# BOJ::1325 효율적인 해킹
[BOJ] : <https://www.acmicpc.net/problem/1325>
- Level : Silver 2

# 시사점
- 중복 방문하지 않기 위해 dfs로 풀어보려 하였지만, 사이클 문제를 해결하지 못하여 실패함.

# 이해(x)

# 설계(x)

## 시간 복잡도

## 공간 복잡도

# 구현(x)

## 단방향 그래프 중 사이클이 있는 경우

## 단방향 그래프 중 사이클이 없는 경우

```cpp
// 현재 코드는, 단방향 그래프에서
// x->y 경로가 존재할때, y->x가 없어야 함
// 즉, 사이클이 없는 경우에만 답이 된다.
#include<bits/stdc++.h>
using namespace std;
const int MAX_N = 10001;

int n, m;
bool grp[MAX_N][MAX_N];
int depth[MAX_N];

int dfs(int cur){
    if(depth[cur] != -1) return depth[cur];
    int ret = 0;
    for(int i = 1; i <= n; i++){
        if(!grp[cur][i] || (cur == i)) continue;
        ret += dfs(i);
    }
    return depth[cur] = ret +1;
}
priority_queue<pair<int, int> > pq;
void solve(){
    memset(depth, -1, sizeof(depth));
    for(int i = 1; i <= n; i++){
        dfs(i);
        pq.push({depth[i], -i});
    }
    int prevSz = -1;
    vector<int> ans;
    while(!pq.empty()){
        int sz = pq.top().first, idx = -pq.top().second; pq.pop();
        if(sz < prevSz){
            //cout << "\n";
            while(!pq.empty())pq.pop();
            break;
        }
        prevSz = sz;
        //cout << idx << " ";
        ans.push_back(idx);
    }
    for(int i = 0; i < ans.size(); i++){
        if(i < ans.size()-1)cout << ans[i] <<" ";
        else cout<<ans[i]<<endl;
    }
}

int main(){
    freopen("input.txt", "r", stdin);
    cin >> n >> m;
    for(int i = 0; i < m ; i ++){
        int x, y;
        cin >> x >> y;
        grp[y][x] = true;
    }
    solve();
    return 0;
}

```


# 디버깅(x)

# 좋은 코드


