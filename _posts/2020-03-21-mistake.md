---
title : 2020년 3월 21일까지 실수 혹은 간과한 점 모음

categories:
    - sweaB
    - BOJ
    - 백준
tag:
    - sweaB
    - BOJ
    - 백준
---

# 실수 모음
- [Link : Jongman](https://beenpow.github.io/jongman/2019/11/24/Jongman1/)
- 좋은 코드를 구성하기 위한 전략 / 실수에 대한 종류 모음


![img2](/img/meta-chart.png)


## 입력/ 출력 / 초기화 오류

| No.  | 사유  | 링크  |
| 1 | n과 m을 반대로 입력 받음  |[Link : BOJ::2948 2009년](https://beenpow.github.io/sweab/boj/%EB%B0%B1%EC%A4%80/2020/03/20/BOJ-2948/)   |
| 2 | endl의 사용으로 받은 시간초과  |[Link : BOJ::2819 상근이의 로봇](https://beenpow.github.io/sweab/boj/%EB%B0%B1%EC%A4%80/2020/02/18/BOJ-2819/)   |
| 3 | queue를 전역변수로 생성하고, 초기화 시키지 않고 사용하였습니다.  |[Link : BOJ::17142 연구소 3](https://beenpow.github.io/sweab/boj/2020/02/06/BOJ-17142/)   |
| 4 | n과 mxh를 입력받고, 말의 갯수를 n으로 초기화 하였습니다. (mxh로 하여야 함) |[Link : BOJ::17837 새로운 게임2](https://beenpow.github.io/sweab/boj/2020/02/03/BOJ-17837/)   |
| 5 | x와 y를 반대로 입력받았습니다.  |[Link : sea::5655 무선 충전기](https://beenpow.github.io/sweab/swea/2020/02/27/swea-5644/)   |
| 6 | 반복문 내에서 특정 값들의 합을 구하는 변수인 internalSum 변수를 초기화 하지 않고 사용하였습니다.  | [Link : sea::5655 무선 충전기](https://beenpow.github.io/sweab/swea/2020/02/27/swea-5644/)  |
| 7 | input받는 범위를 1 <= x < R+1  로 받아야 하지만, 0 <= x < R로 받았습니다. off-by-one 실수이지만, 정점을 사용하는 graph 혹은 경계면 처리를 해주는 graph에서 자주 발생하기 쉽습니다.  |[Link : BOJ::2933 미네랄](https://beenpow.github.io/sweab/boj/%EB%B0%B1%EC%A4%80/2020/03/01/BOJ-2933/)   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |


## 변수 범위 혹은 변수의 잘못된 사용

| No.  | 사유  | 링크  |
|---|---|---|
| 1 | 문제에서 제시되는 입력의 범위를 모두 테스트 케이스로 만들어 볼 필요가 있습니다. double을 출력할 경우 1e+09처럼 일반적으로 생각하지 않는 방법으로 출력되기도 합니다.  |[Link : BOJ::2909 캔디구매](https://beenpow.github.io/sweab/boj/%EB%B0%B1%EC%A4%80/2020/03/20/BOJ-2909/)   |
| 2 | 한 이닝이 시작할때의 선수는, 이전 이닝 마지막 선수 +1번째 선수이어야 합니다. 하지만 매번 0번부터 재시작하였습니다. 즉 변수에 잘못된 값을 대입하여 사용하였습니다.  |[Link : BOJ::17281 야구공](https://beenpow.github.io/sweab/boj/2020/02/03/BOJ-17281/)   |
| 3 | 변수 type이 다른 것끼리의 대소 비교는 큰 문제를 야기할 수 있습니다. 물론, 암시적 형 변환을 통해 자료형이 더 큰 변수로 확장(promotion)되어 사용되지만, 명확히 짚고 넘어가야 합니다.  |[Link : BOJ::1062 가르침](https://beenpow.github.io/sweab/boj/2020/01/24/BOJ-1062/)   |
| 4 | shift연산자의 경우 기본적으로 32비트 정수형에서 사용됩니다. 따라서 64비트 정수에 대해 shift하고 싶다면, (ull)1<<63 처럼 casting해줄 필요가 있습니다.  |[Link : Jongman::16-1](https://beenpow.github.io/jongman/2019/12/16/Jongman-ch16-1/)   |
| 5 | 최대한 적은 수의 변수를 선언하고, 이미 선언한 경우 최대한 적은 변수로 사용하여 접근하여 실수를 줄입니다. 즉 int cache[x][y]를 특정 함수에서 사용한다고 할때, int&ret = cache[x][y]로 사용한다면, 변수 2개로 접근하던 것을 1개로 접근하므로 확률적으로 실수를 줄일 수 있습니다.  |[Link : Jongman::8-1](https://beenpow.github.io/jongman/2019/12/04/Jongman-ch8-1/)   |
| 6 | backtrack문제에서 전역변수로 선언한 변수를 매 함수에서 사용하기 위해서는, 재귀를 보내기 전과 보내고 돌아온 후에 대한 변수 값 변경을 해줘야 합니다. 하지만 해주지 않았기에, 재귀 보낼때와 돌아왔을때의 값이 달라지는 상황이 발생하였습니다.  |[Link : BOJ::17136 색종이 붙이기](https://beenpow.github.io/sweab/boj/2020/02/04/BOJ-17136/)   |
| 7 | off-by-one 실수를 하였습니다. bfs를 빠져나가는 조건, 즉 base조건에 대해서, 특정 값이 10 이상일때 return해야하는지, 10 초과일때 return해야 하는지 명확히 해 줄 필요가 있습니다.  |[Link : BOJ::15644 구슬 탈출 3](https://beenpow.github.io/sweab/boj/2020/02/02/BOJ-15644/)   |
| 8 | 하나의 변수인 map[N][N]이 있습니다. 문제를 풀다보면, 이렇게 현재 위치에서 다음위치로 이동하고, 해당 위치에서 충돌처리를 해주어야 하는 경우가 있습니다. 이때는 data의 일관성을 유지하기 위해 현재 위치 저장하는 변수/ 다음 위치 저장하는 변수를 따로 두는 것이 좋습니다. 하나의 변수에서 사용하는 경우 현재와 다음이 공존하는 순간이 생기기 쉽습니다. |[Link : BOJ::8972 미친 아두이노](https://beenpow.github.io/sweab/boj/2020/01/30/BOJ-8972/)   |
| 9 | 해당 문제 풀이에서 사용된 W[4] 배열에서, W[5]에 접근하여 틀렸습니다를 받았습니다. 반복문을 돌릴때, 마지막 값을 define된 변수로 사용하는 것은 좋지만, 정확히 범위가 어디까지인지 주석으로 써놓으면 실수를 줄일 수 있을 것 같습니다.  |[Link : BOJ::15898 피아의 아틀리에](https://beenpow.github.io/sweab/boj/2020/02/06/BOJ-15898/)   |
| 10| off-by-one 실수를 하였습니다. 문제에서 제시된 k의 범위는 [0,10] 임에도 불구하고, a[10]으로 선언하였습니다.  |[Link : BOJ::16933 벽 부수고 이동하기 3](https://beenpow.github.io/sweab/boj/2020/02/01/BOJ-16933/)   |
| 11| 일종의 off-by-one 실수를 하였습니다. while(){ if(x)y; cmd1;}과 while(){ cmd1; if(x)y;}는 다른 구현입니다. 변수의 초기위치에 대해서 고려하고 커맨드를 실행시킬 것인지, 일단 커맨드를 진행시킬 것인지는 구현이 다르고, 무조건 해당 경우를 고려하고 코드를 구성해야겠습니다.   |[Link : BOJ::17143 낚시왕](https://beenpow.github.io/sweab/boj/2020/02/07/BOJ-17143/)   |
| 12|map과 list를 사용하는 시뮬레이션 문제에서 가장 많이 하는 실수 입니다. 현재지점에서 다음 지점으로 이동할때, 변수를 하나만 사용하는 경우 현재지점과 다음지점 모두에 대해 처리를 해줘야 합니다. 하지만 보통 다음지점으로 넘어가기만 하고 현재지점을 처리하지 않아서 실수가 발생합니다.  |[Link : BOJ::17825 주사위 윷놀이](https://beenpow.github.io/sweab/boj/2020/02/04/BOJ-17825/)   |
| 13| 함수의  base조건에 부합하지 않는 경우 -1을 리턴하였습니다. 하지만 해당 값은 base조건에 부합하더라고 return될 수 있는 값입니다. 즉, 함수에서 return되는 변수의 범위와, 그 값을 받는 변수가 기대하는 범위를 명확히 할 필요가 있습니다.  |[Link : BOJ::3425 고스택](https://beenpow.github.io/sweab/boj/2020/01/07/BOJ-3425/)   |
| 14| C = A * B일때, 곱하기를 통해 overflow가 발생할 수 있습니다. 비슷한 문제들의 경우, A, B, C는 문제에서 제시한 변수 범위 내의 수이지만, 곱하거나 나누거나 빼면서 overflow가 발생하기 쉽습니다. 큰 값을 연산 할때는 민감하게 처리해 주어야 할 것 같습니다.  |[Link : BOJ::3425 고스택](https://beenpow.github.io/sweab/boj/2020/01/07/BOJ-3425/)   |
|15 | int idx = MAXN;과 같이 두고 반복문을 돌린 후에 해당 값이 변경되었는지 확인함으로써 특정 조건문이 실행되었는지 확인하는 경우가 종종 있습니다. 그러기 위해서는 idx에 초기화되는 MAXN의 값은 실제 idx의 범위내에 있는 값이 아니어야 합니다. 즉, 변수의 범위를 명확히 해 두어야 해당 실수를 막을 수 있습니다.  |[Link : BOJ::16235 나무 재테크](https://beenpow.github.io/sweab/boj/2020/02/08/BOJ-16235/)   |
| 16| 문제에서 주어지는 인풋들을 곱해서 나오는 변수의 최대값을 계산하지 않았습니다. 노드가 10^5개이고, 각 노드는 최대 10^9의 값을 가지므로 long long으로 풀어야 하는 문제입니다.  |[Link : BOJ::16437](https://beenpow.github.io/sweab/boj/%EB%B0%B1%EC%A4%80/2020/03/23/BOJ-16437/)   | 1분 | 
| 17| 스티커와 모눈종이가 있습니다. 모눈종이는 전체 맵이고, 스티커를 i, j 2중 for문을 통해 모눈종이가 붙일 곳이 있는지 탐색합니다. 이때 스티커와 모눈종이는 각각 다른 i와 j를 가져야 합니다. 하지만 인덱스 하나만을 사용하여 가능여부를 판단하였습니다.  |[Link : BOJ::18808 스티커 붙이기](https://beenpow.github.io/sweab/boj/%EB%B0%B1%EC%A4%80/2020/03/23/BOJ-18808/)   | 8분 |
| 18 |n의 범위는 2부터이고, n이 2인 경우 예외처리를 해주어야 합니다. 즉, 2를 제외하고 모든 수는 규칙성을 띄지만, 2만 제외되어야 합니다.   |[Link : cofo::round 601](https://beenpow.github.io/sweab/cofo/2020/04/10/cofo-round-601/)   | 10분 |
| 19  |n의 범위는 최대 10^9 입니다. 하지만 저는 주로 INF=987654321으로 사용합니다. 범위를 조심해야겠습니다.|[Link : cofo::round 602](https://beenpow.github.io/sweab/cofo/2020/04/11/cofo-round-602/)   | 5분 |
| 20  |n의 범위는 최대 10^6입니다. 하지만 10^4으로 설정했습니다. 10^x 꼴이 많이 등장하는 문제일수록 더 주의깊게 봐야겠습니다.|[Link : cofo::round 602](https://beenpow.github.io/sweab/cofo/2020/04/11/cofo-round-602/)   | 5분 |

|    |   |   |
|   |   |   |
|   |   |   |


## STL의 잘못된 사용

| No.  | 사유  | 링크  |
|---|---|---|
| 1 | vector 혹은 list와 같은 자료구조에서 erase를 사용하면, 삭제된 지점 바로 다음에 있던 변수의 지점을 리턴해줍니다. 하지만, 삭제한 변수가 마지막 인덱스의 것인 경우 end()를 가리키게 되어버립니다.  |[Link : jongman::조세푸스](https://beenpow.github.io/jongman/2019/12/21/Jongman-ch18-5/)   |
| 2 | bool operator 의 경우 const를 붙여줘야 하는 곳이 두 군데 입니다. bool operator <(const type& x) const{}와 같이 사용하여야 합니다.  |[Link : BOJ::3425 고스택](https://beenpow.github.io/sweab/boj/2020/01/07/BOJ-3425/)   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |


## 테스트 케이스 시뮬레이션

| No.  | 사유  | 링크  |
|---|---|---|
| 1 | 설계상에 오류가 있는 점은 설계 이후 해당 방식으로 테스트케이스를 손으로 그려가며 시뮬레이션 해보는 것만으로도 찾아낼 수 있습니다.  | [Link : BOJ::15559 내 선물을 받아줘](https://beenpow.github.io/sweab/boj/%EB%B0%B1%EC%A4%80/2020/03/16/BOJ-15559/)  |
| 2 | next_permutation이 backtrack보다 오래 걸릴 수 있습니다. next_permutation은 모든 경우의 수를 구합니다. 하지만, 이 중에 중복으로 세는 것이 있다면 backtrack을 통해 순서를 강제해주거나 하는 등의 방법으로 시간을 훨씬 아낄 수 있습니다.  |[Link : Jongman::6-1](https://beenpow.github.io/jongman/2019/11/27/Jongman-ch6-1/)   |
| 3 | 코드 구현 후, 해당 코드로 테스트 케이스를 머릿속으로 시뮬레이션 돌려보았다면 잡을 수 있었을 법한 실수를 했습니다. 초록색 배양액과 빨간색 배양액이 하나의 지점에서 같은 시간대에 만나게 되면 꽃이 피게 됩니다. 하지만, 첫번째 해당 자리에 온 색깔은 해당 위치에 자신이 왔다갔음을 표시하고 이미 큐에 들어가 버립니다. 이후, 다른 색이 와서 해당 자리에 다른 색이 왔다 갔음을 알고 꽃을 피웁니다. 하지만 처음에 온 녀석은 이미 큐에 들어있으므로, 팝하자마자 따로 처리를 해주어야 합니다. 이런 충돌 처리 문제에서는 큐에서 값을 꺼낼때도 조심해야겠습니다.  |[Link : BOJ::18809 Gaaaaaaaaaarden](https://beenpow.github.io/sweab/boj/%EB%B0%B1%EC%A4%80/2020/03/23/BOJ-18809/)   | 15분|
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |


## 단어(문장) 뜻 이해

| No.  | 사유  | 링크  |
|---|---|---|
| 1 | LCA 즉, u와 v의 가장 가까운 공통 조상에 u와 v가 될 수도 있다는 점을 알지 못했습니다. | [Link : BOJ::3485 가장 가까운 공통 조상](https://beenpow.github.io/sweab/boj/%EB%B0%B1%EC%A4%80/2020/03/15/BOJ-3584/)  |
| 2 | 문제에 제시된 등식에 대해 정확히 이해하지 못하고 풀이하였습니다. 이렇게 문제에 처음 보는 정의 혹은 등식이 나오는 경우 정확히 이해하고 시작하여야겠습니다.  |[Link : BOJ::16196 중국 신분증 번호](https://beenpow.github.io/sweab/boj/2020/01/29/BOJ-16196/)   |
| 3 | 문제에 분명히, "가장 아래에 있는 말만 이동할 수 있다"고 주어졌음에도 불구하고 한 정점에 존재하는 각 말들을 이동시켰습니다.  |[Link : BOJ::17837 새로운 게임2](https://beenpow.github.io/sweab/boj/2020/02/03/BOJ-17837/)   |
| 4 | 문제에 제시된 조건을 빠뜨리고 구현하였습니다. 문제를 보면, push의 갯수가 가장 적은 것을 우선순위로 두고, 만약 여러개라면 push+move의 갯수가 적은 것을 우선순위로 두라고 써있습니다만, 빠뜨리고 구현하였습니다.   |[Link : BOJ::6316 Pushing Boxes](https://beenpow.github.io/sweab/boj/%EB%B0%B1%EC%A4%80/2020/03/22/BOJ-6316/)   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |


## 문제에 제시된 개념 정의

| No.  |  사유 | 링크  |
|---|---|---|
| 1 | 어떤 문제이든 간에, 문제에 제시되는 개념들의 정의가 무엇인지 아주 정확하게 이해한 후 구현을 시작해야 하지만, 적당히 이해하고 풀다가 오히려 더 시간이 걸린 문제입니다. 특히나, 벨이 울리는 간격과 언제 들을 수 있는지 등을 손으로 그려보았다면 좋았을 문제입니다.  | [Link : BOJ::1333 부재중 전화](https://beenpow.github.io/sweab/boj/%EB%B0%B1%EC%A4%80/2020/03/12/BOJ-1333/)  |
| 2 | 낮/밤이 바뀌는 주기와 하루가 증가하는 주기에 대한 정의를 정확히 내리지 않고 문제풀이를 시작하였습니다. 문제풀이에 필요한 정의가 나온다면, 수학적으로 정리하고 시작해야 함을 깨우치게 해 줍니다.  | [Link : BOJ::18224 미로에 갇힌 건우](https://beenpow.github.io/sweab/boj/%EB%B0%B1%EC%A4%80/2020/03/08/BOJ-18224/)  |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |


## 잘못된 혹은 건너뛴 설계

| No.  | 사유  | 링크  |
|---|---|---|
| 1 | every single bit단위의 설계는 아니어도, 함수 혹은 for문 정도의 단위가 어떻게 구성되어야 하는지, 토대는 구성하고 문제를 풀어야 합니다. 로직을 명료하게 정리하지 않고서는 제 시간에 문제를 풀 수 없습니다.  | [Link : BOJ::1874 스택 수열](https://beenpow.github.io/sweab/boj/%EB%B0%B1%EC%A4%80/2020/03/10/BOJ-1874/)  |
| 2 | 처음 떠오른 풀이법에 대해서 최소한 1회는 최적화시킬 생각을 해야합니다. 처음 생각한대로 1부터 10^6까지 전처리를 하다가 런타임 오류를 받았습니다. 해당 방법으로 정확히 설계했다면, 시간초과와 스택메모리 초과를 고려되었어야 했고, 그랬다면 새로운 방법으로 바로 다시 착수했을 수 있습니다.  |[Link : BOJ::2231 분해합](https://beenpow.github.io/sweab/boj/%EB%B0%B1%EC%A4%80/2020/03/06/BOJ-2231/) |
| 3 | 경로의 갯수를 세는 문제와 최단거리를 구하는 문제는 설계 방법이 다름에도 불구하고, 문제가 보통 비슷하게 주어지다보니 혼동하여 잘못 사용할 수 있습니다.  |[Link : BOJ::17070 파이프 옮기기 1](https://beenpow.github.io/sweab/boj/2020/02/06/BOJ-17070/)   |
| 4 | square의 모서리만 탐색하는 경우 하나의 정점에서 출발해서 해당 정점을 마지막점으로 도착하게 코드를 구성합니다. 그렇다면 마지막 정점은 마지막 dfs에서 current일까요? next일까요? 이렇게 사소해보이지만 생각하기에 곯머리가 아픈 지점들은 항상 짚고 넘어가야 실수를 줄일 수 있습니다.  |[Link : BOJ::17406 배열 돌리기 4](https://beenpow.github.io/sweab/boj/2020/02/03/BOJ-17406/)   |
| 5 | backtrack함수로 구현할 경우의 수를 잘못 설계하고 풀이를 시작하였습니다. 보통의 backtrack은 index를 하나씩 늘려가며 구현하지만, 그렇지 않게 설계하여 오류를 범했습니다. |[Link : jongman::6-9](https://beenpow.github.io/jongman/2019/11/28/ch6-3/)   |
| 6 | 재귀 함수의 기본 설계는 base를 먼저 구성하는 것입니다. 즉, 함수의 종료 조건을 먼저 정의하고 이후에 나머지 부분에 대한 구현을 진행해야 합니다. 하지만 문제에 따라서 종료 조건이 여러개가 될 수 있게 구현하는 경우, 그 중요성을 간과하기 쉽습니다. 재귀의 base를 확실히 하고 시작해야합니다.  |[Link : jongman::6-2](https://beenpow.github.io/jongman/2019/11/27/Jongman-ch6-2/)   |
| 7 | print할 부분의 시작점인 sx, sy의 값이 for문에 의해 매 글자마다 증가합니다. 따라서 for문이 종료된 후에는 마지막 값의 다음 값을 가리키고 있습니다. 즉, 커맨드를 먼저 실행하고 변수를 증가시키는 방법과 변수를 먼저 증가시키고 커맨드를 실행하는 경우 각각이 다름을 인지하고, 반복문이 끝난 후 해당 변수가 사용될 경우 유의해야 합니다. ex) for(;;){time++;if(x)break; cmd1;}, for(;;){cmd1; if(x) break; time++}  |[Link : BOJ::2290 LCD Test](https://beenpow.github.io/sweab/boj/%EB%B0%B1%EC%A4%80/2020/03/01/BOJ-2290/)   |
| 8 | bfs에서 변수를 하나 꺼냈을때 실수하기 쉬운 부분이 있습니다. 다익스트라 처럼 해당 변수가 이미 다른 변수보다 상대적으로 값이 뒤쳐져서 더이상 필요가 없는 경우,  pop하자마자 제외시켜주는 로직을 추가해줘야 합니다. 물론 다익스트라 문제의 경우 명백하게 해당 로직을 사용하지만, 다음 문제와 같이 cost가 아니라, 특정 지점에 도착했을 경우 더이상 진행을 시킬 필요가 없다던지와 같은 경우 입니다. 즉, queue에서 꺼낼때도 재귀함수처럼 종료조건을 명확히 해주는 것이 중요한 것 같습니다.   |[Link : BOJ::14451 안대 낀 스피드러너](https://beenpow.github.io/sweab/boj/%EB%B0%B1%EC%A4%80/2020/02/23/BOJ-14451/)   |
| 9 | 코드가 길어지는 구현 문제일수록, 사용되는 변수/함수를 정의하고, 값의 범위와 역할을 정확히 명시하게 시작하는 것이 중요합니다. 다음 문제에서는 재료 3개의 순서를 섞는 경우를 빼먹고 구현하였습니다. 또한 답을 도출하는 수식도 잘못 사용하였습니다. 예를들어, sum(A_i) * y를 구해야 하지만 A_i * y를 구했습니다. |[Link : BOJ::15898 피아의 아틀리에](https://beenpow.github.io/sweab/boj/2020/02/06/BOJ-15898/)   |
| 10| bfs의 경우 상태를 정의합니다. 이때 상태 정의에 사용되는 변수가 많아지는 경우 로직이 복잡해집니다. 각 변수의 순서를 바꾸는 것만으로도 로직을 해당 방향으로 구성할 수 있게되어 많은 변화를 일으킬 수 있습니다. 해당 문제에서는, 벽인지아닌지 결정하고 머무를지 말지 판단하는 것과 머무를지 말지 결정하고 벽인지 아닌지 판단하는 것이 각각 로직을 구현하는 것이 다르고 한쪽이 더 단순하게 구현할 수 있음을 언급합니다. |[Link : BOJ::16933 벽 부수고 이동하기 3](https://beenpow.github.io/sweab/boj/2020/02/01/BOJ-16933/)   |
| 11| 주사위 하나를 놓는 경우의 수를 잘못 책정하고 문제를 설계하였습니다. 16가지라고 생각했지만, 실제로는 24가지이므로 당연히 시간을 매우 소모할 수 밖에 없었습니다.  |[Link : BOJ::2598 기둥만들기](https://beenpow.github.io/sweab/boj/%EB%B0%B1%EC%A4%80/2020/02/16/BOJ-2598/) |
| 12| 설계 오류. 경로 탐색 문제를 bfs로 접근하였고, 따라서 두 로직의 차이점을 찾는데 시간을 많이 소모하였습니다.  |[Link : BOJ::1175 배달](https://beenpow.github.io/sweab/boj/%EB%B0%B1%EC%A4%80/2020/03/22/BOJ-1175/)   |
| 13| 문제에서 분명히, 배양 가능한 위치중에서 G+R개의 배양액을 떨어뜨려 시뮬레이션을 진행하라고 언급되어 있습니다. 하지만 배양 가능한 위치 중에서 G+R개를 고르는 부분을 빠뜨리고 설계하여 구현하지 않았습니다.   |[Link : BOJ::18809 Gaaaaaaaaaarden](https://beenpow.github.io/sweab/boj/%EB%B0%B1%EC%A4%80/2020/03/23/BOJ-18809/) |15분|
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |


## 단순 실수

| No.  | 사유  | 링크  |
|---|---|---|
| 1  | current에서 next를 찾은 후, queue에 push하지 않았습니다.  |[Link : BOJ::17141 연구소 2](https://beenpow.github.io/sweab/boj/2020/02/01/BOJ-17141/)   |
| 2 | up방향과 down방향의 순서를 바꿔 사용하였습니다. 코드가 길어질수록 이런 실수가 증가하기 쉽습니다. 손이 빠르게 구현을 하더라도 눈은 꼼꼼히 코드를 훑어가야할 것 같습니다.  |[Link : BOJ::16023 RoboThieves](https://beenpow.github.io/sweab/boj/%EB%B0%B1%EC%A4%80/2020/02/20/BOJ-16023/)   |
| 3 | dx[]={-1, 0, 1, 0}, dy={0, 1, -1, 0}와 같이 선언하였습니다. dx와 dy의 구성이 맞지 않습니다. 보통 키보드를 빨리 칠때 손이 생각보다 먼저 앞서나가서 질서없이 타자를 치느라 이런 실수가 발생하는 것 같습니다. 코드를 구현할때는 200타 이상으로는 구현하지 않기 등의 속도 제한이 필요할 것 같습니다.  또한 보통 이런 실수는 설계에서 변수단위까지 설계하였거나, 자주 사용하는 변수 구성을 사용할때 발생하는 것 같습니다. | [Link : BOJ::17779 게리맨더링 2](https://beenpow.github.io/sweab/boj/2020/01/28/BOJ-17779/)  |
| 4 | 코드의 가독성을 향상시키고자, 더 짧은 코드로 구성하기 위해 다음과 같이 사용하였습니다. if(a) cmd1; cmd2; cmd3; 세 개의 커맨드는 모두 if문에 포함되어야 함에도 불구하고 말입니다.  |[Link : BOJ::17779 게리맨더링 2](https://beenpow.github.io/sweab/boj/2020/01/28/BOJ-17779/)   |
| 5 | if(x &#124;&#124; y)의 경우, x가 참인 경우 y를 실행하지 않습니다. 하지만 y에 꼭 동작해야하는 함수를 걸어놓았습니다. if문에서의 조건문의 역할을 한번 더 생각할 필요가 있습니다. |[Link : BOJ::15644 구슬 탈출 3](https://beenpow.github.io/sweab/boj/2020/02/02/BOJ-15644/)   |
| 6 | bool operator 혹은 비교 연산에 사용되는 함수의 경우 a.x > b.x로 리턴하는 경우가 대부분입니다. 하지만, a.x - b.x로 리턴하였습니다.   |[Link : BOJ::8972 미친 아두이노](https://beenpow.github.io/sweab/boj/2020/01/30/BOJ-8972/)   |
| 7 | 이중 반복문에서 특정 값을 발견하면 두 반복문 모두를 빠져나와야 하는데, 하나만 빠져나오는 오류를 범했습니다. 보통 이런 경우는 함수로 구현해서 바로 return하면 간단해집니다. 그렇지 못하는 경우 flag를 사용하여 빠져나오거나, 정확히 사용할 수 있다면 goto도 사용할 수 있습니다.  |[Link : BOJ::8972 미친 아두이노](https://beenpow.github.io/sweab/boj/2020/01/30/BOJ-8972/)   |
| 8 | char b[N][N]={'.'} 혹은 char b[N][N] = {'.',}과 같은 선언과 동시에 초기화는 [0][0]에만 효과가 있습니다. 이 경우 생성 후에 for문을 통해 따로 초기화를 해주는 것이 안전합니다.   |[Link : BOJ::8972 미친 아두이노](https://beenpow.github.io/sweab/boj/2020/01/30/BOJ-8972/)   |
| 9 | queue에 저장되는 type에 변수의 갯수가 많은 경우, 올바른 순서가 아니게 저장하는 실수를 많이 저지릅니다. 이 문제에서도 변수의 갯수가 6개나 되어서 순서를 섞어서 저장하였습니다. 또한 이런 경우, 처음엔 변수가 3개였지만 하나씩 추가되어서 결국 6개가 되는 경우가 대부분이라, 순서가 꼬이기 더 쉽습니다. 명료하게 따로 떼어내서 배열 변수로 선언하여 사용하는 것이 깔끔하겠습니다.  |[Link : BOJ::14451 안대 낀 스피드러너](https://beenpow.github.io/sweab/boj/%EB%B0%B1%EC%A4%80/2020/02/23/BOJ-14451/)   |
| 10| 특정 block(if문 혹은 반복문) 내에 포함되어야 하는 command인 경우(vice versa), 해당 block 밖에 구현을 하는 실수를 하기도 합니다. 보통 코드가 길어질때 각 부분 부분을 구현하게 되므로 문제 전체에 대한 흐름이 모호해져서 발생하는 것 같습니다. 로직 구현 후, 문제를 다시 보며 logical하게 구현되었는지 더블체크가 필요합니다.  |[Link : swea::2382 미생물 격리](https://beenpow.github.io/sweab/swea/2020/02/11/swea-2382/)   |
|11 | 방문이후, 방문체크를 해주지 않았습니다.  |[Link : BOJ::16236 아기 상어](https://beenpow.github.io/sweab/boj/2020/02/08/BOJ-16236/)   |
|12 | 여러 bfs가 사용되는 문제의 경우, 각 탐색에서 어떤 변수는 방문하고 어떤 값일때는 방문하고, 어떤 값일때는 방문하지 않고를 정의하는 게 좋은 것 같습니다. 해당 문제는 정점 탐색과 경계 탐색 2가지가 포함되어 있습니다. 따라서 정점 탐색={alphabet,'.'}, 경계탐색 = {'+','-','&#124;&#124;'}과 같이 포함된 원소를 정의해주고 시작하는 것이 명료할 것 같습니다.  |[Link : BOJ::17500 국경](https://beenpow.github.io/sweab/boj/%EB%B0%B1%EC%A4%80/2020/02/14/BOJ-17500/)   |
|13 |for(A;B;C)인 반복문에서 C는 총 B-A-1회 실행될 것이라고 생각하였습니다. 하지만 C는 총 B-A번 실행됩니다. 즉 마지막 실행을 세지 않은 것입니다.   |[Link : BOJ::15959 Piet](https://beenpow.github.io/sweab/boj/%EB%B0%B1%EC%A4%80/2020/02/14/BOJ-15949/)   |
|14 | shark의 이동 가능거리를 최소화 시켜주는 전처리 과정에서 곱하기 2를 빠뜨리고 구현하였습니다. 구현 후 시뮬레이션을 눈으로 따라가봤다면 찾을 수 있을법한 오류입니다. |[Link : BOJ::17143 낚시왕](https://beenpow.github.io/sweab/boj/2020/02/07/BOJ-17143/)   |
|15 |over함수에서 y>C를 비교해야하는데, x>C를 비교하였습니다.   |[Link : BOJ::2933 미네랄](https://beenpow.github.io/sweab/boj/%EB%B0%B1%EC%A4%80/2020/03/01/BOJ-2933/)   |
|16 |'U'와 'D'를 바꿔서 써두었습니다.   |[Link : BOJ::17090 미로 탈출하기](https://beenpow.github.io/sweab/boj/%EB%B0%B1%EC%A4%80/2020/03/23/BOJ-17090/)|2분  |
|17 | n과 m의 사이즈가 다른 배열을 회전시키는 경우, swap(n,m)을 한 이후에 회전시켜줘야합니다. 반대로 구현하여서 시간을 소모했습니다.   | [Link : BOJ::18808 스티커 붙이기](https://beenpow.github.io/sweab/boj/%EB%B0%B1%EC%A4%80/2020/03/23/BOJ-18808/)  | 7분 |
|18 | seen[i]의 방문체크를 빼먹고 구현했습니다.   |[Link : cofo::round 602](https://beenpow.github.io/sweab/cofo/2020/04/11/cofo-round-602/)   | 10분|
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |
|   |   |   |










