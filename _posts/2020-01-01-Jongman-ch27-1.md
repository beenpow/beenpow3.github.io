---
title : Ch.27.1 그래프의 표현과 정의

categories:
- jongman

tags:
- jongman
---

# 27.1 도입

- 6부에서는 선형으로 표현하기 힘든 대표적인 구조인 계층 구조를 표현하기 위해 고안된 트리에 대해
  다뤘습니다.
- 여기에서는 계층적인 구조보다 좀더 일반적이고 강력한 자료 구조인 그래프(graph)에 대해 다룹니다.

## 그래프의 정의

> 그래프 G(V,E)는 어떤 자료나 개념을 표현하는 정점(vertex)들의 집합 V와 이들을 연결하는
> 간선(Edge)들의 집합 E로 구성된 자료 구조입니다.

## 그래프의 종류

> 그래프의 속성을 중심으로 설명을 요약해 보았습니다.


![img1](/img/2020-01-01-Jongman-ch27-1-1.png)


```cpp
속성1 : 방향
    - 방향 그래프(directed graph) : 각 간선이 방향이라는 새로운 속성을 갖습니다.
    - 무향 그래프(undirected graph) : 간선에 방향이 없는 그래프 입니다.

속성2 : 가중치
    - 가중치 그래프(weighted graph) : 각 간선에 가중치(weight)라고 불리는 실수 속성을 부여합니다.

속성3 : 형태
    - 다중 그래프(multigraph) : 두 정점 사이에 두 개 이상의 간선이 있을 수 있는 그래프
    - 단순 그래프(simple graph) : 두 정점 사이에 최대 한 개의 간선만 있는 그래프

그 외
    - 트리 혹은 루트 없는 트리(unrooted tree)
      : 부모 자식 관계가 없을 뿐, 간선들의 연결 관계만 보면 트리와 같은 무향 그래프를 말합니다.
    - 이분 그래프(bipartite graph) 
      : 그래프의 정점들을 겹치지 않는 두 개의 그룹으로 나눠서 서로 다른 그룹에 속한 정점들 간에만
        간선이 존재하도록 만들 수 있는 그래프

두 가지 이상의 속성을 갖는 경우
    - 사이클 없는 방향 그래프(DAG, directed acyclic graph)
      : 방향 그래프이며, 한 점에서 출발해 자기 자신으로 돌아오는 경로(사이클)가 존재하지 않는
        경루를 말합니다.

```

## 그래프의 경로

> 경로(path)란 끝과 끝이 서로 연결된 간선들을 순서대로 나열한 것입니다.
- 단순 경로(simple path) : 경로 중 한 정점을 최대 한 번만 지나는 경로
- 사이클(cycle)혹은 회로 : 시작한 점에서 끝나는 경로


# 27.2 그래프의 사용 예

- 그래프는 현실 세계의 수많은 문제를 풀기 위해 이용됩니다.

## 한 붓 그리기

- 유명한 퍼즐 중 하나인 한 붓 그리기 문제는 종이에서 연필을 떼지 않고 주어진 도형을 그리되, 모든
  선을 한 번씩만 지날 수 있는지를 묻는 문제입니다.
- 한 붓 그리기 문제는 주어진 그래프의 모든 간선을 한 번씩만 지나는 경로를 찾는 문제가 되는데, 이
  문제는 오일러 경로(Eulerian path)라고 부르며 깊이 우선 탐색을 응용해서 해결할 수 있습니다.


# 27.3 암시적 그래프 구조들

> 암시적 그래프(implicit graph) : 그래프 같은 형태를 갖는 구조가 아니라도 그래프를 통해서 표현하면
> 쉽게 해결 할 수 있는 구조

## 할 일 목록 정리

- 외출을 해야 할때, 외출복을 입고, 빨래를 하고, 세제를 찾고 등의 순서에 대해,
- 어느 순서대로 하면 되는지를 계산하는 문제를 위상 정렬(topological sorting)이라고 부릅니다.

## 15-퍼즐

- 4x4 크기의 게임판에 1부터 15까지의 숫자가 적힌 열다섯 개의 타일이 끼워져 있고, 이 타일들을 움직여
  원래 있던 순서대로 정렬하는 15-퍼즐 문제 또한 그래프를 응용해 풀 수 있는 유명한 문제입니다.
- 29, 30 장에 나오는 최당 경로 문제를 푸는 여러 전략들에서 다룹니다.

## 게임판 덮기

- 가로 N칸, 세로 N칸으로 나뉘어 있는 정사각형의 게임판을 1 x 2  크기의 블록으로 덮는 문제를 생각해
  봅시다.
- 32장에서 나오는 이분 매칭 알고리즘으로 해결 가능합니다.

## 회의실 배정

- N개의 팀이 각각 회의를 하려고 하는데, 회의실은 하나 뿐인 경우를 생각해 봅시다.
- 이와 같은 문제를 만족성 문제(satisfiability problem)라고 부르는데, 28장에서 이 문제를 그래프에서의
  강 결합성 문제로 변환해서 푸는 방법을 소개합니다.

# 27.4 그래프의 표현 방법

- 많은 경우 그래프는 트리에 비해 훨씬 정적인 용도로 사용됩니다.
- 보다 정적이라는 말은 새로운 정점이나 간선을 추가하고 삭제하는 일이 자주 일어나지 않는다는
  의미입니다.
- 따라서 대부분 그래프는 구조의 변경이 어렵더라도 좀더 간단하고 메모리를 적게 차지하는 방법으로
  구현하곤 합니다.

## 인접 리스트 표현

> 인접 리스트(adjacency list) 표현은 그래프의 각 정점마다 해당 정점에서 나가는 간선의 목록을
> 저장해서 그래프를 표현합니다.

```cpp
vector<list<int> > adjacent;
```
- 이때 adjacent[i] 는 정점 i와 간선을 통해 연결된 정점들의 번호를 저장하는 연결리스트입니다.

- 만약 가중치 그래프 등 간선이 추가적 속성을 갖는 그래프를 표현해야 할땐 아래와 같이 간선의 정보를
  구조체로 표현하여 사용할 수 있습니다.
 
```cpp
struct Edge{
    int vertex; // 간선의 반대쪽 끝 점의 번호
    int weight; // 간선의 가중치
};
```

## 인접 행렬 표현

> 인접 행렬(adjacency matrix)는 이름에서 유추할 수 있듯이 V x V 크기의 행렬, 즉 2차원 배열을
> 이용해 그래프의 간선 정보를 저장합니다.
- 따라서 가장 간단한 형태의 인접 행렬 표현은 단순히 2차원 불린 값 배열이 됩니다.

```cpp
vector<vector<bool> > adjacent;
```
- 가중치 그래프의 경우, 불린 값이 아니라 정수나 실수 변수로 두면 됩니다.
  - 두 정점 사이에 간선이 없는 경우에는 -1 혹은 아주 큰 값등으로 존재할 수 없는 값으로 지정하여
    사용합니다.

## 인접 행렬 표현과 인접 리스트 표현의 비교

> 인접 행렬
- 장점
  - 검색이 O(1)만에 가능합니다.
- 단점
  - V x V 크기의 2차원 배열을 사용하므로, 실제 간선의 개수와 관계없이 항상 O(V^2) 크기의
    공간을 사용합니다.

> 인접 리스트
- 장점
  - |V|개의 연결리스트에 실제 간선 수만큼의 원소가 들어 있으므로, 전체 O(V+E)의 공간만을
    사용합니다.
- 단점
  - 검색을 위해 연결리스트 adjacent[u]를 처음부터 읽어가며 각 원소를 일일이 확인해야 합니다.


- 희소 그래프인 경우 인접리스트를 사용
  - 희소 그래프(sparse graph) : 간선의 수가 V^2에 비해 훨씬 적은 그래프

- 밀집 그래프인 경우 인접 행렬을 사용
  - 밀집 그래프(dense graph) : 간선의 수가 거의 V^2에 비례하는 그래프

## 암시적 그래프 표현
- 입력이 직접적으로 그래프 형태를 띠지 않는 문제의 경우, 그래프 구조를 직접 사용하지 않고도 문제를
  해결할 수 있는 경우가 자주 있습니다.

- 그 예로, 막힌 칸과 열린 칸으로 구성된 미로에서 두 칸 A,B사이의 최단 경로를 찾는 문제를 푼다고
  합시다.
- 각 빈칸을 정수 일련번호를 갖는 정점으로 표현하는 대신, 빈 칸의 위치(y,x)로 표현하면 어떨까요?
- 현재 정점과 인접한 정점을 찾고 싶으면 간선의 목록을 뒤지는 대신 현재 칸의 상하좌우를 검사하면서 각
  칸이 비어있는지 확인하면 되고, 두 정점이 인접해 있는지 확인하려면 두 칸이 인접해 있는지 확인하면
  됩니다.
