---
title : BOJ::3425 고스택

categories:
    - sweaB
    - BOJ
tag:
    - sweaB
    - BOJ
---
# BOJ::3425 고스택
[BOJ]:<https://www.acmicpc.net/problem/3425>
- Level : Gold 2

# 시사점

- 시뮬레이션문제로써, 빡빡하게 경우의 수를 나눠 표현하는 것이 문제가 원하는 바라고 생각합니다.
- 현재 올려놓은 코드로는 33%에서 틀렸습니다가 뜨는 상태이고, 아직 이유를 찾지 못했습니다.

# 이해(20)
- 문제 이해가 쉽지 않았습니다.
- 요약하자면, 프로그램 부분과 입력 부분이있습니다.
  - 프로그램 부분은 명령어들로 이루어져있습니다.

- 즉, 프로그램에 포함된 명령어들을 미리 저장해두고
- 각 입력마다 프로그램 하나를 실행시킨다고 생각하면 좋을 것 같습니다.

# 설계(x)

- 최대한 깔끔하게 풀어보고자, 명령어를 3가지 타입으로 나누어 구현하였습니다.
- stack_size가 2이상 필요한 경우, 1이상 필요한 경우, 그 외의 경우로 나누어 구현하였습니다.
- 추가로, (min,max), (stack_size) 등의 예외처리를 하였습니다.

## 시간 복잡도

## 공간 복잡도

# 구현(x)

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
#define needSize0 0
#define needSize1 1
#define needSize2 4
#define top (stk_sz-1)
#define increaseSize stk_sz++
#define decreaseSize stk_sz--
const int _MAX_INT =1230000000;
const int mx  =     1000000000;
const int mn  = mx * -1;

const char END[]="END";
const char QUIT[]="QUIT";
const int MAX_CMD = 10;
const char cmds[10][4]={"NUM","POP","INV","DUP","SWP","ADD","SUB","MUL","DIV","MOD"};
enum cmdsDefine{ NUM = 0, POP, INV, DUP, SWP, ADD, SUB, MUL, DIV, MOD };

int stk_sz;
int stack[1010];

int prg_sz;
int prg[100010][2];

// 각 명령어마다 필요한 사이즈가 있고, 그 사이즈의 체크 결과를 반환합니다.
bool ableSize(int cmd, int sz){
    if(cmd >= needSize1 && cmd < needSize2 && sz < 1) return false;
    if(cmd >= needSize2 && sz < 2) return false;
    return true;
}
// 사이즈2짜리 연산 결과가 합당한지 여부를 반환합니다.
bool isResultOkSize2(){
    bool ret = true;
    stack[top] = 0;
    decreaseSize;
    if(stack[top] < mn || stack[top] > mx) ret = false;
    return ret;
}
// a = first, b = second
// first will be poped;
void _swap(int&a, int&b){int c = a; a = b; b = c;}
void _add(int& a, int& b){b+=a;}
void _sub(int& a, int& b){b-=a;}
void _mul(int& a, int& b){b*=a;}
void _div(int& a, int& b){b/=a;}
void _mod(int& a, int& b){b%=a;}
void _abs(int& a){(a = (a<0?-a:a));}
// 사이즈2짜리 연산의 결과가 합당한지 여부를 반환합니다.
bool implementSize2(int cmd){
    bool ret = true;
    bool minus = false;
    switch (cmd) {
        case SWP:
            _swap(stack[top], stack[top-1]);
            break;
        case ADD:
            _add(stack[top], stack[top-1]);
            ret = isResultOkSize2();
            break;
        case SUB:
            _sub(stack[top], stack[top-1]);
            ret = isResultOkSize2();
            break;
        case MUL:
            _mul(stack[top], stack[top-1]);
            ret = isResultOkSize2();
            break;
        case DIV:
            if(stack[top] == 0){ ret = false; break; }
            if((stack[top] < 0 && stack[top-1] >0) || (stack[top] > 0 && stack[top-1] <0)) minus = true;
            _abs(stack[top]);
            _abs(stack[top-1]);
            _div(stack[top], stack[top-1]);
            if(minus) stack[top-1] *= -1;
            ret = isResultOkSize2();
            break;
        case MOD:
            if(stack[top] == 0){ ret = false; break; }
            if(stack[top-1] <0) minus = true;
            _abs(stack[top]);
            _abs(stack[top-1]);
            _mod(stack[top], stack[top-1]);
            if(minus) stack[top-1] *= -1;
            ret = isResultOkSize2();
            break;
        default:
            while(1);
            break;
    }
    return ret;
}
// 사이즈1짜리 연산을 진행합니다.
void implementSize1(int cmd){
    if(cmd == POP){
        stack[top] = 0;
        decreaseSize;
    }else if(cmd == INV){
        stack[top] *= -1;
    }else if(cmd == DUP){
        stack[top+1] = stack[top];
        increaseSize;
    }
}

int solve(int firstValue){
    int ret = 0;
    // 초기화
    for(int i = 0; i < stk_sz; i++) stack[i] = 0;
    stk_sz = 1;
    stack[top] = firstValue;

    // 프로그램내의 명령어 순차적 수행
    for(int i = 0; i < prg_sz; i++){
        if(stack[top] < mn || stack[top] > mx){ret = _MAX_INT; break;}
        if(stk_sz == 0){ret = _MAX_INT; break;}
        int cmd = prg[i][0], num = prg[i][1];
        if(ableSize(cmd, stk_sz) == false){ret = _MAX_INT; break;}

        // SWP, AND, SUB, MUL, DIV, MOD
        if(cmd >= needSize2){
            bool isValid = implementSize2(cmd);
            // 0으로 나누거나, 0으로 나눈 나머지를 취하려 하는 경우
            // 연산의 결과가 절대값으로 10^9 범위를 넘어갈 때 false값을 갖습니다.
            if(isValid == false){ret = _MAX_INT; break;}

        // POP INV DUP
        }else if(cmd >= needSize1){
            implementSize1(cmd);

        // NUM X
        }else{
            stack[stk_sz] = num;
            increaseSize;
        }
        if(stack[top] < mn || stack[top] > mx){ret = _MAX_INT; break;}
        if(stk_sz == 0){ret = _MAX_INT; break;}
    }
    if(stk_sz != 1) ret = _MAX_INT;
    if(ret != _MAX_INT) ret = stack[top];
    return ret;
}

// 입력된 명령어의 넘버링을 반환합니다.
int getCmd(char A[]){
    for(int i = 0; i < MAX_CMD; i++){
        if(strcmp(cmds[i], A) == 0)return i;
    }
    return -1;
}

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    freopen("input.txt", "r", stdin);
    int first = 0;
    while(true){
        first++;
        // program
        bool isEnd = false, isQuit = false;
        char program[20]={0};
        int num = 0;
        // set program size, program
        while (true) {
            cin >> program;
            if(strcmp(program, END) == 0){isEnd = true; break;}
            if(strcmp(program, QUIT) == 0){isQuit = true; break;}
            int cmd = getCmd(program);
            if(cmd == 0) cin >> num;
            else num = 0;
            prg[prg_sz][0] = cmd; prg[prg_sz++][1] = num;
        }
        if(isQuit) break;
        if(first != 1) cout << endl;
        // input
        int cnt, first;
        cin >> cnt;
        for(int i = 0; i < cnt; i++){
            cin >> first;
            int ret = solve(first);
            if(ret == _MAX_INT) cout << "ERROR" << endl;
            else cout << ret << endl;
        }
        //cout << endl;
        prg_sz = 0;
    }

    return 0;
}
```

# 디버깅(x)

- 실수 1 : solve 에서 실패한 경우 ret = -1로 사용했었음.(음수 -1이 stack[top]인 경우 겹친다.)
