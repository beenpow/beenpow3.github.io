---
title : Ch.24.6 펜윅트리

categories:
- jongman

tags:
- jongman
---

# 24.6 펜윅 트리 : 빠르고 간단한 구간 합

- 구간 트리의 가장 흔한 사용 예는 바로 구간 합을 빠르게 구하는 것입니다.
- 이 경우 구간 트리 대신 쓸 수 있는 구간 트리의 궁극적인 진화 형태로 펜윅 트리(Fenwick Tree)혹은
  이진 인덱스 트리(binary indexed tree)라고 불리는 것이 있습니다.

- 16장 비트마스킹 참조
- <https://beenpow.github.io/jongman/2019/12/16/Jongman-ch16-2/>

## 펜윅 트리의 idea

- 펜윅 트리가 사용하는 중요한 아이디어는 구간 합 대신 부분 합만을 빠르게 계산할 수 있는 자료 구조를
  만들어도 구간 합을 계산할 수 있다는 것입니다.
  - 부분 합(partial sum) -> p[i] = 0부터 i까지의 합
  - 구간 합(range sum)   -> 구간 [a,b]에 대한 연속된 부분 배열의 합

- psum[pos] = A[0] + A[1] + ... + A[pos]를 빠르게 구할 수 있으면,
- 구간 [i,j]에 대한 합은 psum[j] - psum[i]로 계산할 수 있습니다.

- 부분 합만을 계산한다고 생각하면, 구간 트리가 미리 계산해 저장하는 정보의 상당수는 필요가 없습니다.
- 그림 (a)는 길이 16인 배열의 구간 합을 구하기 위해 구간 트리가 계산해 저장하는 구간들을 보여줍니다.

> 이때 [8, 15] 구간의 합은 사실 부분 합만을 구한다면 필요가 없습니다.
- 구간 합 [8, 15] = psum[15] - psum[7] 로 구할 수 있습니다.
- 즉, 하나의 긴 구간 밑에 두 개의 작은 구간이 있을 때 두 구간 중 오른쪽 구간은 항상 지워도 됩니다.

![img1](/img/2019-12-30-Jongman-ch24-6-1.png)

- 그림 (b)는 이 구간 중 필요한 부분만 남긴 결과를 보여줍니다.
- 남은 구간의 수는 정확하게 n개 입니다.
- 펜윅 트리는 이 대응을 이용해 1차원 배열 하나에 각 구간의 합을 저장합니다.

```cpp
tree[i] = 그림 (b)에서 오른쪽 끝 위치가 A[i]인 구간의 합
```

## 구간 합 계산

- A[pos] 까지의 구간합 psum[pos]를 계산하고 싶으면 그림 (b)에서 pos에서 끝나는 구간의 합 tree[pos]를
  답에 더합니다.
  - 즉, (b)에서 색칠한 구간 tree[12], tree[11], tree[7]들은 psum[12]를 계산하기 위해 더해야 하는
    구간들을 나타냅니다.
  - 어떤 부분 합을 구하든 O(logN) 개의 구간 합만 있으면 된다는 사실을 쉽게 알 수 있습니다.


## pos에서 끝나는 구간 다음으로 더해야 할 구간 찾기

- 이제 문제는 pos에서 끝나는 구간 다음으로 더해야 할 구간을 어떻게 찾을까 하는 것입니다.
- 펜윅 트리는 각 숫자의 이진수 표현을 이용해 이 문제를 해결합니다.
> 우선 이를 위해 배열 A[]와 tree[]의 첫 원소의 인덱스를 1로 바꿉시다.
- 모든 원소의 인덱스에 1을 더해 주면 됩니다.

![img2](/img/2019-12-30-Jongman-ch24-6-2.png)

> 각 구간의 길이는 이진수 표현에서 오른쪽 끝에 있는 0의 개수가 하나 늘 때마다 두 배로 늘어납니다.
- ex) psum[7]을 구하기 위해 더해야 하는 숫자는
    - 7에서 끝나는 구간의 합 tree[7] 111
    - 6에서 끝나는 구간의 합 tree[6] 110
    - 4에서 끝나는 구간의 합 tree[4] 100
- 즉, 다른 부분 합에 대해서 일일이 확인해 보면 오른쪽 끝 위치의 이진수 표현에서 마지막 비트를 지우면
  다음 구간을 쉽게 찾을 수 있음을 알 수 있습니다.

> 최종 비트 지우기
- pos-1과 비트별 AND하는 법을 사용합니다.(16장)
- pos &= (pos-1)

## 펜윅 트리 채워 넣기

- 펜윅 트리를 처음 생성하면 모든 부분 합이 0으로 초기화되므로, 모든 원소가 0인 배열을 표현하게
  됩니다.
- 펜윅 트리는 구간 트리처럼 모든 구간에 대해 답을 계산하지 않기 때문에 O(n)에 초기화하기가
  불가능합니다.

> 따라서 펜윅 트리에서 배열의 값을 변경하는 것은 해당 위치의 값에 숫자를 더하고 빼는 것으로
> 구현합니다.
- ex) A[5]를 3 늘리고 싶다고 합시다. 이때 늘려 줘야 할 값들은
    - tree[5]  101
    - tree[6]  110
    - tree[8]  1000
    - tree[16] 10000
- 즉, 다른 경우들도 하나하나 시도해 보면 맨 오른쪽에 있는 1인 비트를 스스로에게 더해 주는 연산을
  반복하면 해당 위치를 포함하는 구간들을 모두 만날 수 있음을 알 수 있습니다.
    - 예를 들어 110 에서 가장 오른쪽에 있는 비트는 10 이므로, 이를 스스로에게 더하면 1000을 얻을 수
      있습니다.

> 마지막 비트 추출하기
- (pos & -pos) (16장)


```cpp
// 펜윅 트리의 구현. 가상의 배열 A[]의 부분 합을
// 빠르게 구현할 수 있도록 한다. 초기화시에는 A[]의
// 원소가 전부 0이라고 생각한다.
struct FenwickTree{
    vector<int> tree;
    FenwickTree(int n) : tree(n+1) {}
    // A[0 .. pos]의 부분 합을 구한다.
    int sum(int pos){
        // 인덱스가 1부터 시작한다고 생각하자.
        ++pos;
        int ret = 0;
        while(pos > 0){
            ret += tree[pos];
            // 다음 구간을 찾기 위해 최종 비트를 지운다.
            pos &= (pos-1);
        }
        return ret;
    }
    // A[pos]에 val을 더한다.
    void add(int pos, int val){
        ++pos;
        while(pos < tree.size()){
            tree[pos] += val;
            pos += (pos & -pos);
        }
    }
};
```
