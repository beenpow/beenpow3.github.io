---
title : Ch.28.4 오일러 서킷

categories:
- jongman

tags:
- jongman
---

> 해당 챕터 정리
- 오일러 서킷
  - 무향 그래프
  - 유향 그래프
- 오일러 트레일
  - 무향 그래프
  - 유향 그래프

# 28.4 오일러 서킷

> 오일러 서킷(Eulerian circuit)
- 깊이 우선 탐색을 이용해 풀 수 있는 또 다른 유명한 문제로, 그래프의 모든 간선을 정확히 한 번씩
  지나서 시작점으로 돌아오는 경로를 찾는 문제가 있습니다.
  - 이와 같은 경로를 그래프 이론에서는 오일러 서킷(Eulerian circuit)이라고 부릅니다.
  - 한붓 그리기 문제로 생각하시면 이해가 쉽습니다.
- 먼저 무향 그래프에 대해 오일러 서킷을 정의합니다.

> 오일러 서킷은 어느 경우에 존재하는가?
- 오일러 서킷이 존재하지 않는 경우
  - 가장 당연한 경우로, 그래프의 간선들이 두 개 이상의 컴포넌트로 나뉘어 있는 경우
- 오일러 서킷이 존재하는 경우
- 그래프의 모든 정점들이 짝수점인 경우
  - 모든 정점에 들어가는 횟수와 나오는 횟수가 같아야 하는데, 홀수점이라면 이와 같은 일이 
    불가능하기 때문입니다.
    - 차수(degree) : 한 정점에 인접한 간선의 수
    - 짝수점 : 차수가 짝수인 정점
    - 홀수점 : 차수가 홀수인 정점


## 오일러 서킷을 찾아내는 알고리즘

> 오일러 서킷의 원리는 이번 챕터에서 이해하고, 함수 구현법은 다음 챕터에서 하는 것이 좋을 것
> 같습니다.

- 어떤 그래프의 모든 정점이 짝수점이고, 모든 간선이 하나의 컴포넌트에 포함되어 있다고 합시다.
- 이때 임의의 정점 u에서 시작해 아직 따라가지 않은 간선 중 하나를 따라가며 임의의 경로를 만드는 함수
  findRandomCircuit(u)를 만들어 봅시다.
  - 이 함수는 현재 정점에 인접한 간선 중 아직 따라간 적 없는 임의의 간선을 따라가기를 반복하다가,
    더이상 따라갈 간선이 없을 때 종료합니다.
  - findRandomCircuit()이 찾는 경로의 끝점은 어디일까요?
    - 그래프의 모든 정점은 짝수점이므로, 시작점 외의 다른 정점에서 종료하는 것은 불가능합니다.
    - 따라서 항상 시작점에서 끝나게 되고, 이름대로 findRandomCircuit()이 찾아낸 경로는 항상 서킷이
      됩니다.
    - 운 좋게도 이 서킷이 이미 모든 간선을 지나쳤다면 오일러 서킷을 찾은 셈이니 곧장 종료할 수
      있습니다.
    - 만약 아니라면 어떻게 할까요?
    - 서킷의 각 정점들을 하나하나 돌아보며, 아직 따라가지 않은 간선과 인접해 있는 정점을 찾도록 합시다.
    - 간선들이 모두 하나의 컴포넌트에 포함되어 있기 때문에, 아직 따라가지 않은 간선이 남아 있는 정점은
      항상 존재할 수밖에 없습니다. 이 정점을 v라고 부릅시다.

- v에 인접한 간선 중 우리가 따라가지 않고 남아 있는 간선의 수는 몇 개일까요?
  - 원래 v또한 짝수점이었을 텐데, 우리가 처음에 찾은 경로가 v를 지나가면서 짝수 개의 간선을 사용했기
    때문에 짝수 개의 간선이 남을 수밖에 없습니다.
  - 따라서 v에서 시작하도록 findRandomCircuit()을 다시 수행하면 새로운 하나의 서킷을 얻게 됩니다.
  - 우리가 원하는 것은 모든 간선을 포함하는 하나의 서킷이므로, 이 두서킷을 합쳐야 합니다.
  - 다행히 처음에 찾았던 서킷을 v에서 자른 뒤, 여기에 새로운 서킷을 끼워넣어 하나의 큰 서킷을 쉽게
    만들 수 있습니다.

- 아래 그림에서 이와 같은 알고리즘의 동작 과정을 볼 수 있습니다.
  - u에서 시작해서 findRandomrCircuit()을 수행한 결과, (a)에서 실선으로 표시된 사이클을 얻었다고
    합시다.
    - 이 서킷은 모든 간선을 포함하지 않으므로, 서킷을 따라 뒤로 돌아가면서 아직 인접한 간선이 남아
      있는 정점을 찾아야 합니다.
  - 그런 정점 v를 만나면 여기에서부터 시작해서 다시 서킷을 찾습니다.
  - 결과적으로 그림 (b)와 같은 서킷을 얻을 수 있는데, 이 두 서킷을 합쳐 그림 (c)와 같이 커다란
    서킷을 만들 수 있습니다.
- 이와 같은 일을 서킷이 모든 간선을 포함할 때까지 반복하면 오일러 서킷을 쉽게 찾을 수 있습니다.

- 덧붙이자면, (a)에서 v의 간선을 짝수개(2개)만 사용한 것을 알 수 있습니다.
  - (b)에서도 남은 짝수개(2개)를 사용한 것을 알 수 있습니다.

![img1](/img/2020-01-01-Jongman-ch28-4-1.png)

## 깊이 우선 탐색을 이용한 구현

- 지금껏 설명한 방법을 곧이 곧대로 구현하기란 꽤나 까다롭습니다.
- 깊이 우선 탐색을 응용한 구현을 이용하면 아주 간단하게 이 알고리즘을 구현할 수 있습니다.

- 눈여겨볼 부분은 이 코드에는, 정점에 따라가지 않은 간선이 남아 있을 때 새 서킷을 만들어서 지금까지
  만든 서킷의 가운데에 끼워넣는 코드가 없다는 점입니다.
  - 어떻게 이것이 가능할까요?
  - 비결은 각 간선을 따라갈 때 경로에 추가하는 것이 아니라, 재귀 호출이 끝나고 반환할 때 추가하는
    것입니다.
  - 결과적으로 circuit에는 경로의 끝점부터 역순으로 간선들이 추가됩니다.
  - 따라서 어떤 정점에 아직 따라가지 않은 간선이 있을 때, circuit에는 지금까지 찾은 서킷의 뒷
    부분만이 저장되어 있습니다.
  - 따라서 새 서킷을 찾더라도, 서킷의 중간에 끼워 넣는 대신, 지금까지 만든 부분의 맨 뒤에 붙이고
    나머지 부분을 계속 만들기만 하면 됩니다.
  - 결과적으로 얻은 서킷을 뒤집어야 한다는 문제는 있지만 이렇게 하면 훨씬 구현이 간단해집니다.

```cpp
// 그래프의 인접 행렬 표현. adj[i][j] = i와 j 사이의 간선의 수
vector<vector<int> > adj;
// 무향 그래프의 인접 행렬 adj가 주어질 때 오일러 서킷을 계산한다.
// 결과로 얻어지는 circuit을 뒤집으면 오일러 서킷이 된다.
void getEulerCircuit(int here, vector<int>& circuit){
    for(int there = 0; there < adj[here].size(); ++there)
        while(adj[here][there] > 0){
            adj[here][there]--; // 양쪽 간선을 모두 지운다.
            adj[there][here]--;
            getEulerCircuit(there, circuit);
        }
    circuit.push_back(here);
}
```

- 각 간선마다 getEulerCircuit() 함수를 호출하고, 그 내부에서는 O(V)의 반복문을 수행하기 때문에
  알고리즘 전체의 시간 복잡도는 O(VE)가 됩니다.
  - 인접리스트의 경우 시간복잡도는 줄어들지만, 구현이 까다롭습니다.


## 오일러 트레일

- 오일러 서킷처럼 그래프의 모든 간선을 정확히 한 번씩 지나지만, 시작점과 끝점이 다른 경로를 오일러
  트레일(Eulerian trail)이라고 부릅니다.
- 주어진 그래프에서 오일러 트레일을 찾는 문제는 사실 아주 간단하게 오일러 서킷을 찾는 문제로 변환할
  수 있습니다.

- 간단히 설명을 요약하자면,
  - 시작점과 끝점은 홀수점
  - 나머지 점들은 모두 짝수점
- 이라는 조건을 만족하면 됩니다.
